---
title: "An end to end workflow for differential gene expression using Affymetrix microarrays"
author: 
  - name: Bernd Klaus
    affiliation: EMBL Heidelberg, Meyerhofstrasse 1, 69117 Heidelberg, Germany, bernd.klaus@embl.de
  - name: Stefanie Reisenauer
    affiliation: EMBL Heidelberg, Meyerhofstrasse 1, 69117 Heidelberg, Germany, steffi.reisenauer@tum.de
header-includes:
  - \usepackage{float}
摘要: 在这篇文章里，我们将阐述用 Bioconductor 包 an end-to-end Affymetrix microarray differential expression 的工作流程。这个工作流程可以直接应用在目前 “基因” 类型的微陈列，例如 HuGene 或 MoGene 微陈列，同时也容易调整并适用于类似的平台。在这里进行分析的数据是来自典型的临床微陈列数据集，用来对比两种疾病亚型中发炎和非发炎的结肠组织。针对每种疾病，发炎和非发炎的结肠组织的差异基因表达被进行了分析。我们将从原始数据 CEL 文件开始，展示如何将其导入为 Bioconductor 的 ExpressionSet，实施质量控制和归一化和最终的差异基因表达分析，其次是一些显著性分析。
keywords: Microarray, Gene Expression
bibliography: MAEndToEnd.bib
output:
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
csl: f1000-research.csl
date: 14 September 2018
vignette: >
  %\VignetteIndexEntry{An end to end workflow for differential gene expression using Affymetrix microarrays}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---
<!-- latest version from github -->
<!-- devtools::install_github("b-klaus/maEndToEnd", ref = "master") -->

<!--Html rendering for Bioc Workflow using BiocStyle-->
<!-- rmarkdown::render("MA-Workflow.Rmd") -->


<!-- pdf rendering using to F1000 template from Mike's BiocWorkflowTools  -->
<!-- also keeps .tex files for overleaf submission -->
<!-- rmarkdown::render("MA-Workflow.Rmd", output_format = BiocWorkflowTools::f1000_article(keep_tex = TRUE)) -->

<!-- command to compile the vignette using Rscript to check the mem usage -->
<!-- Rscript --vanilla test_mem.R -->


<!--  Conversions between f1000 / BioStyle by Leo Torres -->
<!-- https://stat.ethz.ch/pipermail/bioc-devel/2018-April/013237.html -->
<!-- His example recount workflow that compiles to both BioC and F1000  -->
<!-- https://github.com/LieberInstitute/recountWorkflow/blob/master/vignettes/recount-workflow.Rmd -->



```{r biocSetup, include = FALSE, results="hide", warning=FALSE, echo=FALSE}
## Changing the YAML to the following changes the output to 'latex'
## output:
## BiocWorkflowTools::f1000_article
## More at:
## https://stackoverflow.com/questions/35144130/in-knitr-how-can-i-test-for-if-the-output-will-be-pdf-or-word

## add figures to current directory if Rmd is converted to LaTeX
## This simplifies processing on overleaf

if (!is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))) {
    
    to_html <- knitr::opts_knit$get("rmarkdown.pandoc.to") != 'latex'
        if (!to_html) {
          knitr::opts_chunk$set(fig.path = "", out.width = '.8\\linewidth')
        } 

}
## here, pdf specific adapations can be made
## however, the option "rmarkdown.pandoc.to" is only set by rmarkdown::render,
## so it returns NULL if run interactively!

```

```{r testAlternativeToChunkAbove, eval=FALSE, include=FALSE, echo=FALSE}
# this does not work as it will only test the output formats
# specified in the YAML header
any(grepl("f1000", rmarkdown::all_output_formats(knitr::current_input()))) 
```


```{r knitrOptions, include=FALSE}
library(BiocStyle)
library(knitr)
options(digits = 4, width = 80)
opts_chunk$set(echo = TRUE, 
               tidy = FALSE, 
               include = TRUE,
               dev = c('png'),
               fig.width = 6, fig.height = 3.5,
               comment = '  ', 
               dpi = 300, cache = TRUE,
               fig.pos = "H")

```


<p>
**R 版本**: `r R.version.string`
<br />
**Bioconductor 版本**: `r BiocManager::version()`
<br />
**包版本**: `r packageVersion("maEndToEnd")`
</p>


# 介绍

在这篇文章里我们将介绍典型的（Affymetrix）微阵列分析的完整
工作流程。从数据导入，前期处理，差异基因表达和显著性分析都会
被讨论。

使用的数据 [@Palmieri_2015] 来自于一篇研究发炎和非发炎组
织中差异基因表达的论文。
测试了 14 个患有溃疡性结肠炎 (UC)的病人和 15 个患有克罗恩病
（CD) 的病人，然后通过活检提取了每个病人发炎和未发炎的结肠粘
膜组织。
这个典型的临床数据集共由 58 个阵列构成。我们的目标是分析组织
间的差异表达（DE）。
我们的结果显示了与原始论文结果的大量重叠。

# 工作流程包的安装

工作流程被包裹在叫做 `maEndToEnd` 的包里。

`maEndToEnd` 包目前可以从 GitHub 获得，
目前可用的开发版本为 Bioconductor (3.8) (看这里:<http://bioconductor.org/packages/devel/workflows/html/maEndToEnd.html>).

## 从 Bioconductor 安装工作流程包

你可以通过 `r CRANpkg("BiocManager")`安装包。

```{r installBioc, eval=FALSE}
if (!require("BiocManager"))
    install.packages("BiocManager")
BiocManager::install("maEndToEnd", version = "devel")
```

目前，工作流程可在 Bioconductor（3.8）的开发版本中获得， 这将
成为 2018 年 10 月的发布版本。

有关如何使用这个版本 Bioconductor 的详细信息见：

<http://bioconductor.org/developers/how-to/useDevel/>

## 从 Github 安装工作流程包

```{r, echo=TRUE, results="hide", warning=FALSE, eval=FALSE}

#为了从 GitHub下载包，我们需要来自 “remotes” 的包里中 
#“install_github”的功能。我们用 
#devtool::install_github 从 GitHub下载了最新的开发
#版本的 "remotes" 函数；注意：这是必要的。
#目前在CRAN上面的 “remotes” 版本不允许我们正确的下载 "maEndToEnd"包：

install.packages("devtools")
library(devtools)

devtools::install_github("r-lib/remotes")
library(remotes)
packageVersion("remotes") # has to be 1.1.1.9000 or later

remotes::install_github("b-klaus/maEndToEnd", ref="master")

```

## 工作流程包的导入

成功安装工作流程包后，
我们可以使用对library() 的调用来加载它。
它还将加载运行工作流程所需的所有其他包。

```{r maEndToEndImport}
suppressPackageStartupMessages({library("maEndToEnd")})
```

## 工作流程所需要的包列表

下面，您可以找到工作流程所需的软件包列表。
这里已经注释了一些 Helper/Styling 包，
它们不是执行工作流所必需的。

```{r pkgList, results="hide"}
#通常的 Bioconductor 包
    library(Biobase)
    library(oligoClasses)
     
#注释和数据导入包
    library(ArrayExpress)
    library(pd.hugene.1.0.st.v1)
    library(hugene10sttranscriptcluster.db)
     
#质量控制和前期处理包
    library(oligo)
    library(arrayQualityMetrics)
     
#分析和统计包
    library(limma)
    library(topGO)
    library(ReactomePA)
    library(clusterProfiler)
     
#绘图和颜色选项包
    library(gplots)
    library(ggplot2)
    library(geneplotter)
    library(RColorBrewer)
    library(pheatmap)
     
#格式化/文档包
   #library(rmarkdown)
   #library(BiocStyle)
    library(dplyr)
    library(tidyr)

#助手包 (Helpers)
    library(stringr)
    library(matrixStats)
    library(genefilter)
    library(openxlsx)
   #library(devtools)

```


# 从 ArrayExpress 下载原始数据

分析的第一步是下载原始数据CEL文件。
这些文件由阵列扫描仪软件生成，包含测量的探针强度。我们使用的数据已存放在 [ArrayExpress](https://www.ebi.ac.uk/arrayexpress/) 上，
其登记号为 **E-MTAB-2967**.

我们将这些文件存储在 **raw\_data\_dir** 目录中，
该目录默认为临时目录。

```{r generateFolderForRawData}
raw_data_dir <- tempdir()

if (!dir.exists(raw_data_dir)) {
    dir.create(raw_data_dir)
}

```


每个 ArrayExpress 数据集都有一个总结数据集的登陆页面， 
我们使用`r Biocpkg("ArrayExpress") ` Bioconductor 包中的 `getAE` 函数获取原始数据文件的
ftp 链接 ([Data from Palmieri et. al. on ArrayEpress](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2967/)).


使用下面的代码，我们使用`getAE`函数
从 [ArrayExpress](https://www.ebi.ac.uk/arrayexpress/) [@Kolesnikov_2014] 下载原始数据（也包括注释数据）。
数据保存在上面创建的  `raw_data_dir`中。
下载文件的名称将作为列表返回。


```{r getDataEBI, eval=TRUE, results='hide', message=FALSE}
anno_AE <- getAE("E-MTAB-2967", path = raw_data_dir, type = "raw")
```

我们现在将仔细研究从 ArrayExpress 下载的数据。

# 有关数据的背景信息

## ArrayExpress 里储存的信息

ArrayExpress 中的每个数据集都根据 
MAGE-TAB（微阵列基因表达式表格）规范存储为与
原始数据捆绑在一起的表的集合。  
MAGE-TAB 格式指定最多五种不同类型的文件：


* **调查说明格式 (IDF)**
* **阵列设计格式 (ADF)**
* **样本和数据关系格式 (SDRF)**
* **原始数据文件** 
* **处理过的数据文件**

除原始数据文件外，
IDF 和 SDRF 文件对我们很重要。  
IDF 文件包含有关实验的顶级信息，
包括标题，说明，提交者联系详细信息和协议。  
SDRF 文件包含有关实验样本的基本信息，例如他们所属的实验组。

在我们继续进行实际的原始数据导入之前，
我们将简要介绍`r Biocpkg("Biobase")` 包中包含的 `ExpressionSet` 类。
它通常用于在 Bioconductor 中存储微阵列数据。

## Bioconductor ExpressionSets

基因组数据可以非常复杂，
通常由许多不同的组分组成，例如，
有关实验样品的信息，测量的基因组特征的注释
以及实验数据本身。
在 Bioconductor 中， 采用的方法是将这些组件存储
在一个单结构中以便于管理数据。

`r Biocpkg("Biobase")`  包含标准化数据结构以表示基因组数据。
`ExpressionSet` 类旨在将几个不同的信息源
（即包含在各种 MAGE-TAB 文件中）组合
成一个方便的结构。
可以操纵 ExpressionSet（例如，子集化，复制）
并且是许多 Bioconductor 函数的输入或输出。

ExpressionSet 中的数据包括：

* **assayData**: 来自微阵列实验的表达数据，其中每行是微阵列探针，每列是样品标识符。
其中每行是微阵列探针，每列是样品标识符。
* **metaData**
    + **phenoData**: 实验中样本的描述，每行是样本标识符，每列是描述元素; 储存的是 SDRF 文件的内容。
    + **featureData**: 有关芯片功能的元数据或者用于实验的技术，
    默认情况下使用与 assayData 相同的行和可自由分配的列。
    + 进一步注释特征，例如来自生物医学数据库（注释）的基因注释。
    例如来自生物医学数据库（注释）的基因注释。

* **experimentData**: 一种灵活的结构来描述实验。

ExpressionSet 类协调所有这些数据，因此不必
担心细节。 但是，应该记住，`phenoData` 的 rownames （行名）必须与 assay data 的列名匹配，
而 assayData 的行名必须与 `featureData` 的行名匹配。
这在图1中说明。 \@ref(fig:sumexp).


```{r sumexp, fig.cap = "Structure of Bioconductor’s ExpressionSet class.", echo=FALSE, fig.show="asis", fig.width = 7, fig.height = 4.5}
par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 150),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")

polygon(c(50,85,85,50),c(70,70,130,130),col="lightcoral",border=NA)
polygon(c(55, 56, 56, 55),c(70,70,130,130),col=rgb(1,0,0,.5),border=NA)
polygon(c(50,85,85,50),c(118,118,120,120),col=rgb(1,0,0,.5),border=NA)
text(67.5,100,"assay(s)", cex = 1)
text(67.5,90,"e.g. 'exprs'", cex = 1)

polygon(c(45,49,49,45),c(70,70,130,130),col="honeydew2",border=NA)
text(47,100, "microarray probes", srt=90, cex=1)

polygon(c(50,85,85,50),c(131,131,140,140),col="darkseagreen3",border=NA)
text(67.5,135.5,"sample IDs", cex = 1)


polygon(c(20,40,40,20),c(70,70,130,130),col=rgb(0,0,1,.5),border=NA)
polygon(c(20,40,40,20),c(118,118,120,120),col=rgb(0,0,1,.5),border=NA)
text(30,100,"featureData", cex = 1)

polygon(c(15,19,19,15),c(70,70,130,130),col="honeydew2",border=NA)
text(17,100, "microarray probes", srt=90, cex=1)

polygon(c(20,40,40,20),c(131,131,140,140),col="bisque3",border=NA)
text(30,135.5,"features", cex = 1)

polygon(c(50,65, 65, 50),c(55, 55, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
polygon(c(55, 56, 56, 55),c(55, 55, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
text(57.5, 30,"phenoData", cex = 1, srt=270)

polygon(c(50,65, 65, 50),c(56,56,65,65),col="darkseagreen3",border=NA)
text(57.5,60.5,"sample IDs", cex = 1)
```

您可以使用函数 ` pData ` 和 ` fData ` 分别从 
` ExpressionSet ` 中提取样本和要素注记。
函数 ` exprs ` 将表达式数据本身作为矩阵返回。

# 导入注释数据和微阵列表达数据为 "ExpressionSet"

我们使用原始数据文件夹中的 `read.delim` 函数导入
SDRF 文件，以获取样本注释。

样本名称在 SDRF 数据表的 Array.Data.File 列中给出，并将用作 SDRF 文件的 rownames 。

我们将 SDRF 表转换为 `r Biocpkg("Biobase")` 包中
的 `AnnotatedDataFrame` ，稍后我们将需要为我们的数据
创建一个 `ExpressionSet`[@Bioc].

```{r getSDRF}
sdrf_location <- file.path(raw_data_dir, "E-MTAB-2967.sdrf.txt")
SDRF <- read.delim(sdrf_location)

rownames(SDRF) <- SDRF$Array.Data.File
SDRF <- AnnotatedDataFrame(SDRF)
```


我们现在创建 Expression Set object 
`raw_data`,它包含陈列数据，pheno data (表型数据)
（来自 SDRF 文件） 以及所使用
的芯片注释包的信息。


Affymetrix 列阵的分析是从 CEL 文件开始。这些是使用 
Affymetrix 软件处理原始图像文件
并包含估计的探针强度值的结果。每个 CEL 文件还包含一些元数据，
例如芯片标识符。

我们使用 `r Biocpkg("oligo") ` 包[@oligo]中的 `read.celfiles`  
函数导入文件：

```{r importCelfiles, results="hide", eval=TRUE, dependson="getSDRF", warning = FALSE }
raw_data <- oligo::read.celfiles(filenames = file.path(raw_data_dir, 
                                                SDRF$Array.Data.File),
                                    verbose = FALSE, phenoData = SDRF)
stopifnot(validObject(raw_data))
```

这会自动创建一个 ExpressionSet,
用 CEL 文件中的数据填充部分 "array data"
并使用正确的芯片注释包，在本例中为 
`r Biocannopkg("pd.hugene.1.0.st.v1") ` (
芯片类型也存储在 .CEL 的文件)。

此外，我们将早先从 SDRF 文件创建的 `AnnotatedDataFrame`
 "`SDRF`" 指定为 `phenoData`. 因此，
我们必须确保按照与 SDRF 表对应的顺序导入 CEL 文件
- 为了强制执行此操作，我们使用 `SDRF`
表的 `Array.Data.File` 列作为 `filenames` 
(文件名) 参数。

最后，我们检查了创建的对象是否有效
(例如，不同表之间的样本名称是否匹配）。

我们现在首先看一下原始数据。

Biobase 包的 `pData` 函数直接访问 ExpressionSet `raw_data` 中的 phenoData。使用 `head()` 函数，我们可以查看
表的前六行。我们需要查看包含的列，
并仅保留与感兴趣的实验因子
相关的列。

```{r inspectPhenoData, eval=TRUE }
head(Biobase::pData(raw_data))
```


我们感兴趣的列如下：

  * 个人的标识符，即列名 "Source.Name", "Characteristics.individual."
  * 个体的疾病，即名为 "Factor.Value.disease."
  * 粘膜类型，即名为 "Factor.Value.phenotype."

我们现在再次选择相应的列： 

```{r reassignpData, eval=TRUE}
Biobase::pData(raw_data) <- Biobase::pData(raw_data)[, c("Source.Name",
                                     "Characteristics.individual.",
                                     "Factor.Value.disease.",
                                     "Factor.Value.phenotype.")]
```

# 原始数据的质量控制

初始数据导入后的第一步是数据的质量控制。 
在这里，我们检查异常值并尝试查看数据是否按预期聚类，
例如 由实验条件。 表达强度值在 
assayData 子对象 "exprs" 中，并且可以由 `exprs(raw_data)` 
函数访问。 每行代表微阵列探针，即 
芯片上的单个 DNA 位置，
而每列代表一个微阵列，
即每个患者的发炎和非发炎组织的样品。

```{r inspectAssayData, eval=TRUE}
Biobase::exprs(raw_data)[1:5, 1:5]
```


对于质量控制，我们采用 `Biobase::exprs(raw_data) `的 log2，
因为表达数据通常以 log 分析。

然后，我们执行主成分分析（PCA）并绘制它 \@ref(fig:qualityControlRawDataPCA))
图中的每个点代表一
个样本，颜色表示粘膜类型
(发炎与未发炎）和表示疾病的形状（ UC 或 CD ）。



```{r qualityControlRawDataPCA, fig.cap="PCA plot of the log–transformed raw expression data."}
exp_raw <- log2(Biobase::exprs(raw_data))
PCA_raw <- prcomp(t(exp_raw), scale. = FALSE)

percentVar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
                    Disease = pData(raw_data)$Factor.Value.disease.,
                    Phenotype = pData(raw_data)$Factor.Value.phenotype.,
                    Individual = pData(raw_data)$Characteristics.individual.)

ggplot(dataGG, aes(PC1, PC2)) +
      geom_point(aes(shape = Disease, colour = Phenotype)) +
  ggtitle("PCA plot of the log-transformed raw expression data") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(4,15)) + 
  scale_color_manual(values = c("darkorange2", "dodgerblue4"))
```

原始数据的 PCA 图 (Figure \@ref(fig:qualityControlRawDataPCA), 在对数强度标度上进行
) 显示 第一主成分 (first PC) 区分疾病。  
这意味着
疾病类型是基因表达差异的主要驱动因素。
这可能会妨碍我们的分析，因为我们想要分析发炎组织和非发炎组织之间的差异表达，
而不是人们患病的疾病的关系。

我们还通过箱形图图表示探针强度，
每个单独的微阵列是有一个箱。(Figure \@ref(fig:qualityControlRawDataBox)). 注意， 
`oligo::boxplot` 函数，即 oligo 包的 boxplot() 函数，
可以将表达式集作为参数。
它访问表达式数据并默认执行 log2 转换。 因此，我们可以在这里使用 `raw_data` 作为参数。

```{r qualityControlRawDataBox, fig.cap="Intensity boxplots of the log2–transformed raw data."}
oligo::boxplot(raw_data, target = "core", 
               main = "Boxplot of log2-intensitites for the raw data")
```

当查看箱形图 (Figure \@ref(fig:qualityControlRawDataBox)) 时，
我们看到各个阵列的强度分布完全不同，
这表明需要进行适当的归一化，
我们将在下面讨论。

到目前为止，我们只进行了非常基本的质量控制; 
`r Biocpkg("arrayQualityMetrics")` [@AQM] 中提供了
更精细的质量控制图。 该软件包可以生成一个 html 报告，
其中包含质量控制图以及对其目标的描述以及可能的异常值的识别。
我们在此不详细讨论此工具，
只是提供下面的代码，
它为我们的原始数据创建报告。

```{r arrayQualityMetricsRaw, eval = TRUE, warning=FALSE, message=FALSE}
arrayQualityMetrics(expressionset = raw_data,
    outdir = tempdir(),
    force = TRUE, do.logtransform = TRUE,
    intgroup = c("Factor.Value.disease.", "Factor.Value.phenotype."))
```

# 背景调整，校准，摘要和注释

## 背景调整

在初始导入和质量评估之后，
处理微阵列数据的下一步是背景调整。
这是必要的因为测量的探针强度的一部分
是由于非特异性杂交和光学检测系统中的噪声。
因此，需要调整观察到的强度
以给出特定杂交的准确测量。

## 跨阵列归一化（校准）

因为许多差异的来源并不明确，
所以要标准化跨阵列以便能够比较来自不同阵列杂交的测量结果。
这些包括逆转录，
标记或杂交反应的不同效率，
阵列的物理问题，
试剂批次效应
和实验室条件。 

## 概要

我们必须在归一化后进行汇总，
因为在Affymetrix平台上，
转录本由多个探针表示，即阵列上的多个位置。
对于每个基因，需要将所有探针的背景调整
和标准化强度总结为一个量，
让预计与 RNA 转录物的量成比例的量。

在汇总步骤之后，汇总数据可以用各种信息注释，
例如，基因符号和 ENSEMBL 基因标识符。
Bioconductor 为我们的平台提供了一个注释数据库，
即
`r Biocannopkg("hugene10sttranscriptcluster.db") `包。

您可以像这样查看其内容：

```{r annotationDataBaseContent, eval = TRUE}
head(ls("package:hugene10sttranscriptcluster.db"))
```

更多信息可从包装的参考手册中获得。
本质上该包提供从转录本簇标识
符到各种注释数据的映射。

## Affymetrix 微阵列的新旧 “探针组”

传统来说，Affymetrix 阵列（所谓的3'IVT 阵列）基于探针组：
某一固定探针组是探针组的一部分，
该探针组代表某种基因或转录物
但请注意，基因可由多个探针组表示）。

最近的“基因”和“外显子” Affymetrix 阵列是基于外显子的，
因此有两个级别的总结可以达到基因水平。探针组”总结导致外显子水平。基因/转录物水平由“转录物簇”给出。 因此，我们的芯片类型的适当注释包
名为 
`r Biocpkg("hugene10sttranscriptcluster.db") `.

通过仅从外显子阵列中获取“好”的探针，
“基因”阵列被创建为“外显子”阵列的负担得起的版本。 
最初在外显子阵列上，至少有四个探针是一个“外显子”的一部分。
通过稀释的“基因”阵列，许多探针组由三个或更少的探针组成。
这在图4 中可视化：\@ref(fig:DifferenceBetweenExonAndGeneTypeArrays)
单个探针组由单色标注; 
表示一个基因的探针组用色调表示：
例如，所有黄色探针属于一个外显子，
并且所有黄色，橙色和红色探针组属于一个基因： 

```{r DifferenceBetweenExonAndGeneTypeArrays, fig.width=7, fig.height=6, echo=FALSE, fig.cap="Visualization of the difference between \"Exon\" type array (left) and \"Gene\" type array (right)."}
library(grid)

par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 20),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")
dat <- data.frame(x = rep(seq(0, 2.9, 0.1), 30), 
                  y = rep(seq(0, 2.9, 0.1), each = 30))


col <- c("blue", "darkslategray1", "goldenrod1", "yellow", "royalblue1", "coral")
dat$colours<-sample(rep(col, 150))
dat$colours2 <- sample(c(rep("yellow", 2), rep("goldenrod1", 5), rep("coral",7), 
                  rep("blue", 5), rep ("darkslategray1",3), rep("royalblue1", 8), rep(gray(0:9/10), 87)))

# opening the graphic device and
# setting up a viewport with borders:
vp1 <- viewport(x = 0.1, y = 0.1, w = 0.12, h = 0.12, 
                just = c("left", "bottom"), name = "vp1")


# plotting rectangles using x/y positions
grid.rect(x=dat$x,y=dat$y, height=0.1, width=0.1, hjust=0,vjust=0,vp=vp1,
          gp=gpar(col=1, fill=as.character(dat$colours)))

##########################

vp2 <- viewport(x = 0.5, y = 0.1, w = 0.12, h = 0.12,
                just = c("left", "bottom"), name = "vp1")


# plotting rectangles using x/y positions
grid.rect(x=dat$x,y=dat$y, height=0.1, width=0.1, hjust=0,vjust=0,vp=vp2,
          gp=gpar(col=1, fill=as.character(dat$colours2)))
```


在左侧，我们看到每个外显子/探针组（即每种颜色）有大量探针：
因此，探针组/外显子水平上的摘要是合理的。
然而，在基因型阵列中，
每个探针组仅包括一小部分原始探针。
因此，不建议对 “基因” 阵列使用探针组/外显子级别进行汇总，
但仍然可以使用 `r Biocannopkg("hugene10stprobeset.db") ` 
注释包。

注意，此外，“基因”和“外显子”型芯片上
也不再存在指定的匹配/错配探针。 
错配探针最初用作背景校正的基础水平，
但由于更精细的背景校正技术
不需要不匹配探针而没有普及。

## 一步预处理寡核苷酸

`r Biocpkg("oligo") ` 包允许我们在一个步骤里使用用于背景校正，
归一化，和汇总。
这个包使用反卷积方法来背景校正，分位数归一化和
RMA (robust multichip average) 算法来汇总。

整个系列步骤通常称为 RMA 算法，
但严格来说 RMA 仅仅是一种汇总的方法
[@Irizarry_2003; @Bolstad_2003; @Irizarry_2003a].

# 相对日志表达式数据质量分析

在校准和评估数据之前，我们要执行另一个质量控制程序，
即相对对数表达式（RLE），
如 Gandolfo et al [@Gandolfo_2018]。 
我们首先执行没有事先规范化 RMA：

```{r RMAcalibrationForRLE, eval=TRUE}
palmieri_eset <- oligo::rma(raw_data, target = "core", normalize = FALSE)
```

在 RLE 分析之后，或当执行 “完整” RMA（包括归一化）时， 
将提供关于 RMA 算法的进一步细节。

## 计算 RLE

通过计算所有阵列上每个转录物的 log2 
强度中值来进行 RLE。

我们通过计算 `exprs(palmieri_eset)`的行中值来做到这一点，
因为转录本由每行表示，
单个微阵列由每列表示。

注意，我们不必手动应用 log2，
因为默认情况下 RMA 函数的输出数据为 log2 比例。

然后我们通过  `sweep`函数从每个转录物强度中
减去该转录物中值强度。

## 绘制 RLE 图

我们最终将数据重新整形为一种格式，我们可以使用这种格式 
为每个数组创建一个箱形图 (boxplot) ，如前所述：


```{r boxplotDataForRLETidy, fig.cap="Boxplot for the RLE values", warning=FALSE}
row_medians_assayData <- 
  Biobase::rowMedians(as.matrix(Biobase::exprs(palmieri_eset)))

RLE_data <- sweep(Biobase::exprs(palmieri_eset), 1, row_medians_assayData)

RLE_data <- as.data.frame(RLE_data)
RLE_data_gathered <- 
  tidyr::gather(RLE_data, patient_array, log2_expression_deviation)

ggplot2::ggplot(RLE_data_gathered, aes(patient_array,
                                       log2_expression_deviation)) + 
  geom_boxplot(outlier.shape = NA) + 
  ylim(c(-2, 2)) + 
  theme(axis.text.x = element_text(colour = "aquamarine4", 
                                  angle = 60, size = 6.5, hjust = 1 ,
                                  face = "bold"))
```

注意，现在 y 轴显示的是针对每个微阵列表达强度
与跨阵列的相应单个转录物
的表达中值的偏差。

因此，具有较大延伸的盒子表示在许多转录物中
与中值的异常高偏差，
表明这些阵列在某些方面与大多数其他阵列不同。

与大多数其他阵列相比，在 y 方向上移位的框表示
大多数转录物的系统性更高或更低的表达。
这可能是由质量问题或批量效应引起的。 

因此，如果给定盒子的形状和中位数与体积相差太大，
则应检查并可能将其移除。

通过检查图 5 中的箱线图 \@ref(fig:boxplotDataForRLETidy), 
可以将五个阵列视为异常值:
2826_I，2826_II，3262_II，3302_II 和 3332_II 被负 y 移位。 

我们将记住这些样本，
以便稍后在工作流程中进行热图聚类分析。 
通过热图分析确认为异常值的阵列可以在后续分析前移除。


# RMA 校准数据

现在，我们可以将完整的 RMA 算法应用于我们的数据，
以便进行背景校正，规范化和总结：

```{r RMAcalibrationWITHnormalization, eval=TRUE}
palmieri_eset_norm <- oligo::rma(raw_data, target = "core")
```

参数 `target` 用来定义摘要的程度，
默认选项是“核心”，
使用含有“安全”注释基因的转录物簇。对于外显子级别的汇总（不建议用于基因阵列)，
可以使用 "probeset" 作为 target 选项。
虽然存在其他背景校正和归一化方法，
但 RMA 通常是一个很好的默认选择。
RMA 跨阵列共享信息，
并使用通用的分位数归一化方法，
使阵列强度分布匹配。但是，最好只在
删除异常值后才应用它。
RMA 使用的分位数归一化算法
通过将数值替换为数组中相同排名（单个芯片内）值的平均值来工作。
更详细的描述可以在
维基百科页面上找到 [Wikipedia page](https://en.wikipedia.org/wiki/Quantile_normalization).

分位数归一化的替代方案是 `r Biocpkg("vsn") ` 算法，
其通过在对数变换之前对阵列内的强度值
进行鲁棒地移位和缩放来执行背景校正和归一化。
这跟分位数归一化 [@vsn] 比不那么“严重”。

## 关于归一化（校准）和背景校正的一些数学背景知识

微阵列上单个探针的强度 \(Y\) 值的通用模型
由下式给出：

\[
    Y = B + \alpha \cdot S
\]
    
其中 B 是由于背景噪音引起的随机数量，
通常由光学效应和非特异性结合组成， \(\alpha\) 是增益因子，
 \(S\) 是测量的特异性结合量。 信号 \(S\) 
也被认为是随机变量， 
并且考虑了测量误差和探测效应。
通常假设测量误差是乘法的，因此我们可以写：

\[
    \log(S) = \theta + \varphi + \varepsilon
\]
    
这里 \(\theta\) 表示真实丰度的对数，
\(\varphi\) 是探针特异性效应 $\varepsilon$ 表示
非特异性误差。
这是 RMA 使用的微阵列数据的加法 - 乘法 - 误差模型
以及 `r Biocpkg("vsn") ` 算法 [@vsn]. 算法的不同之处
在于去除 \(B\) 并获得 \(\theta\) 的估计。


## 校准数据的质量评估

我们现在使用校准数据生成聚类热图
和另一个 PCA 图。

**PCA 分析**

首先，我们对校准数据进行 PCA 分析，
类似于原始数据：

```{r PCAMetricsCalibrated, fig.cap = "PCA plot of the calibrated, summarized data.", eval = TRUE }
exp_palmieri <- Biobase::exprs(palmieri_eset_norm)
PCA <- prcomp(t(exp_palmieri), scale = FALSE)

percentVar <- round(100*PCA$sdev^2/sum(PCA$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA$x[,1], PC2 = PCA$x[,2],
                    Disease = 
                     Biobase::pData(palmieri_eset_norm)$Factor.Value.disease.,
                    Phenotype = 
                     Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.)


ggplot(dataGG, aes(PC1, PC2)) +
      geom_point(aes(shape = Disease, colour = Phenotype)) +
  ggtitle("PCA plot of the calibrated, summarized data") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(4,15)) + 
  scale_color_manual(values = c("darkorange2", "dodgerblue4"))
```

与 RMA 之前的第一次 PCA 分析相比 (Figure \@ref(fig:qualityControlRawDataPCA)), 我们看到现在第一个主要成分 PC 
在组织类型之间分离 (Figure \@ref(fig:PCAMetricsCalibrated))。
这表明现在组织类型之间的差异表达
是变异的主要来源。 注意，第二 PC
分离疾病。

**热图聚类分析**

我们想要绘制具有样本到样本距离的热图，
样本名称为行名。 此外，我们希望看到样本分别表现为表型
（发炎和非发炎组织）和疾病（UC和CD）的程度。 
我们使用行注释：这意味着这些功能获得颜色代码并将显示在每行的左侧。

```{r rownamesForHeatmap, fig.height = 8.5, fig.width = 7, eval = TRUE, echo=TRUE}
phenotype_names <- ifelse(str_detect(pData
                                    (palmieri_eset_norm)$Factor.Value.phenotype.,
                             "non"), "non_infl.", "infl.")

disease_names <- ifelse(str_detect(pData
                                    (palmieri_eset_norm)$Factor.Value.disease.,
                             "Crohn"), "CD", "UC")

annotation_for_heatmap <- 
  data.frame(Phenotype = phenotype_names,  Disease = disease_names)

row.names(annotation_for_heatmap) <- row.names(pData(palmieri_eset_norm))

```

为了映射样本到样本的距离， 
我们首先使用 `dist` 函数计算距离。我们需要转换表达式值，
因为函数默认计算行之间的距离（例如我们的基因)。
默认距离是欧几里德距离。然而，这可以改变，
我们在这里选择曼哈顿距离 
（它使用沿矩形路径的绝对距离而不是直接路径的平方距离），
因为它更稳健。
我们将距离矩阵的对角线设置为 ` NA ` ，
以增加颜色编码的对比度。 
那些对角线条目不包含信息，
因为样本到自身的距离总是等于零。


```{r HeatmapWithAnnotation, fig.height = 8.5, fig.width = 7, fig.cap="Heatmap of the sample-to-sample distances"}
dists <- as.matrix(dist(t(exp_palmieri), method = "manhattan"))

rownames(dists) <- row.names(pData(palmieri_eset_norm))
hmcol <- rev(colorRampPalette(RColorBrewer::brewer.pal(9, "YlOrRd"))(255))
colnames(dists) <- NULL
diag(dists) <- NA

ann_colors <- list(
  Phenotype = c(non_infl. = "chartreuse4", infl. = "burlywood3"),
  Disease = c(CD = "blue4", UC = "cadetblue2")
                   )
pheatmap(dists, col = (hmcol), 
         annotation_row = annotation_for_heatmap,
         annotation_colors = ann_colors,
         legend = TRUE, 
         treeheight_row = 0,
         legend_breaks = c(min(dists, na.rm = TRUE), 
                         max(dists, na.rm = TRUE)), 
         legend_labels = (c("small distance", "large distance")),
         main = "Clustering heatmap for the calibrated samples")
```
在热图 (Figure \@ref(fig:HeatmapWithAnnotation)) 中，
我们还发现样品不会被组织强烈聚集，
证实了 PCA 图 (Figure \@ref(fig:PCAMetricsCalibrated)) 的印象，
即组织之间的分离并不完美。热图中的黄色条纹
可能对应于可能被删除的异常值：这里可以标记的异常值
是 2826_II, 3262_II, 3271_I, 2978_II 和 3332_II。
因为发现 2826_II, 3262_II 和 3332_II 在 RLE 和热图分析中都是异常值，
因此可能被删除; 但是，
为了尽可能接近原始论文，
我们继续提供完整的样本集。
注意  `r Biocpkg("arrayQualityMetrics")`包提供了更精细的标识
来识别和删除异常值。


# 根据强度过滤

我们现在过滤掉低表达的基因。微阵列数据通常
在背景强度范围内显示大量探针。 这些探针
在数组之间也没有太大变化。因此，
它们结合了低方差和低强度。因此，它们最终可能被检测为差异表达，
尽管它们几乎不高于 “detection” 限制并且
通常不是非常有用的信息。 

我们将在这里执行基于“软”强度的过滤，因为这是
 `r Biocpkg("limma")` [@limma; @Smyth_2004] 用户指南推荐的
(我们将在下面用于差异表达式分析的包
差异表达式分析的包)。 

但请注意，基于方差的过滤器在实践中可能会排除
一组类似的探测。  
对于基于强度的过滤，我们从表达式数据计算行式中位数， 
因为它们代表转录中位数，并将它们分配给
`palmieri_medians`。从这里我们创建一个直方图：

```{r IntensityBasedManualFiltering, fig.cap="Histogram of the median intensities per gene"}
palmieri_medians <- rowMedians(Biobase::exprs(palmieri_eset_norm))

hist_res <- hist(palmieri_medians, 100, col = "cornsilk1", freq = FALSE, 
            main = "Histogram of the median intensities", 
            border = "antiquewhite4",
            xlab = "Median intensities")
```

在基因中位数的直方图中 (Figure 
\@ref(fig:IntensityBasedManualFiltering))，
我们可以清楚地看到左侧低中值的富集。
这些代表了我们想要过滤的基因。 为了推断数据的截止，
我们检查直方图：我们在直方图峰的左侧可视地设置截止线 `man_threshold` 
以便不排除太多基因。  在我们的示例中，
我们选择阈值 4 。我们绘制与之前相同的直方图，
并使用 `abline()` 函数添加阈值线：

```{r setManualThreshold, fig.cap="Histogram of the median intensities per gene with manual intensity filtering threshold (red line)."}
man_threshold <- 4

hist_res <- hist(palmieri_medians, 100, col = "cornsilk", freq = FALSE, 
            main = "Histogram of the median intensities",
            border = "antiquewhite4",
            xlab = "Median intensities")

abline(v = man_threshold, col = "coral4", lwd = 2)
```

Transcripts that do not have intensities larger than the threshold in 
at least as many arrays as the smallest experimental group are excluded. 

In order to do so, we first have to get a list with the number 
of samples (=arrays) (`no_of_samples`) in the experimental groups: 

```{r expGroups, dependson="PCAMetricsCalibrated"}
no_of_samples <- 
  table(paste0(pData(palmieri_eset_norm)$Factor.Value.disease., "_", 
                  pData(palmieri_eset_norm)$Factor.Value.phenotype.))
no_of_samples 
```


We now filter out all transcripts 
that do not have intensities greater than the threshold in at least 
as many arrays as the smallest experimental group (`r min(no_of_samples)`) 
which we  define as `samples_cutoff`. 

A function `idx_man_threshold` is then applied to each row, i.e. 
to each transcript  across all arrays.
It evaluates whether the number of arrays where the median intensity passes the
threshold (`sum(x > man_threshold)`) is greater than the `samples_cutoff` and 
returns TRUE or FALSE for each row, i.e. each transcript.

We then create a table of `idx_man_threshold` to summarize the results and
get an overview over how many genes are filtered out. 
In the last step, we subset our expression set to `palmieri_manfiltered` 
and keep the TRUE elements of `idx_man_threshold`.

```{r filteringOfLowIntensity_transcripts}
samples_cutoff <- min(no_of_samples)

idx_man_threshold <- apply(Biobase::exprs(palmieri_eset_norm), 1,
                           function(x){
                          sum(x > man_threshold) >= samples_cutoff})
                          table(idx_man_threshold)

palmieri_manfiltered <- subset(palmieri_eset_norm, idx_man_threshold)
```


# Annotation of the transcript clusters

Before we continue with the linear models for microarrays and differential
expression, we first add "feature data", i.e. annotation
information to the transcript cluster identifiers stored in the featureData of
our ExpressionSet: 

```{r annotateData, eval=TRUE, dependson="intensityBasedFiltering", message = FALSE}
anno_palmieri <- AnnotationDbi::select(hugene10sttranscriptcluster.db,
                                  keys = (featureNames(palmieri_manfiltered)),
                                  columns = c("SYMBOL", "GENENAME"),
                                  keytype = "PROBEID")

anno_palmieri <- subset(anno_palmieri, !is.na(SYMBOL))
```

We used the function `select` from `r Biocpkg("AnnotationDbi") ` to query 
the gene symbols and associated short descriptions for the transcript clusters. 
For each cluster, we added the gene symbol (`SYMBOL`) and a short description
of the gene the cluster represents (`GENENAME`). 

In a second step, we filtered out the probes that do not map to a gene,
i.e. that do not have a gene symbol assigned. 

## Removing multiple mappings 

Many transcript-cluster identifiers will map to multiple gene symbols, i.e. 
they can't be unambigously assigned.

We compute a summary table in the code below to see how many there are:


```{r multipleMappings, dependson="annotateData"}
anno_grouped <- group_by(anno_palmieri, PROBEID)
anno_summarized <- 
  dplyr::summarize(anno_grouped, no_of_matches = n_distinct(SYMBOL))

head(anno_summarized)

anno_filtered <- filter(anno_summarized, no_of_matches > 1)

head(anno_filtered)

probe_stats <- anno_filtered 

nrow(probe_stats)
```

First, we grouped `anno_palmieri` by their PROBEID; that way, 
the subsequent operations are not carried through for each single row, 
but for each  group, i.e. each PROBEID.
We then summarized the groups and indicate the number of different genes 
assigned to a transcript cluster in the column `no_of_matches`. 
Finally, we filtered for PROBEIDs with multiple matches, 
i.e. `no_of_matches > 1`.

With `dim(probe_stats)`, we could see how many 
probes have been mapped to multiple genes.

We have close to 2000 transcript clusters that map to multiple gene symbols.
It is difficult to decide which mapping is "correct". Therefore,
we exclude these transcript clusters. 

We want to remove those probe IDs that match the ones in `probe_stats`, 
as those are the probes with multiple mappings. We assign these IDs 
to the variable `ids_to_exclude`. Then, we generate `palmieri_final`, 
an expression set without the `ids_to_exclude`. 

```{r excludeMultipleMappingsFromAssayData, dependson="multipleMappings"}
ids_to_exlude <- (featureNames(palmieri_manfiltered) %in% probe_stats$PROBEID)

table(ids_to_exlude)

palmieri_final <- subset(palmieri_manfiltered, !ids_to_exlude)

validObject(palmieri_final)
```

As we have just excluded probe IDs from the assay data, we now have 
to also exclude them from the feature data `anno_palmieri`:

```{r recallAnnoPalmieri}
head(anno_palmieri)
```

Recall that `fData` enables us to access the feature data of an expression set.
Until now, no feature data whatsoever is stored in the `fData(palmieri_final)`.
Only the row names are the row names of the assay data by default, which are the 
PROBEIDs of the transcripts.

Therefore, we generate a column PROBEID in `fData(palmieri_final)` and 
assign the row names of `fData(palmieri_final)` to it:

```{r excludeMultipleMappingsFromFeatureData}
fData(palmieri_final)$PROBEID <- rownames(fData(palmieri_final))
```

Then, we left-join `fData(palmieri_final)`with `anno_palmieri`, which already contains 
the columns "SYMBOL" and "GENENAME".
A left-join keeps the rows and columns of the first argument 
and adds the corresponding column entries of the second argument:

```{r excludeMultipleMappingsFromFeatureData2}
fData(palmieri_final) <- left_join(fData(palmieri_final), anno_palmieri)


# restore rownames after left_join
rownames(fData(palmieri_final)) <- fData(palmieri_final)$PROBEID 
    
validObject(palmieri_final)
```

By left-joining with `anno_palmieri`, we thus add the "SYMBOL" and "GENENAME" 
columns from `anno_palmieri` for only the PROBEIDs that are in 
`fData(palmieri_final)` and thus get the feature Data for the filtered probes.


## Building custom annotations

Alternatively, one can re-map the probes of the array
to a current annotation. A workflow to do this for Illumina arrays is given in
@Arloth_2015.
Essentially, the individual probe sequences are re-aligned to an in-silico
"exome" that consists of all annotated transcript exons.

In any case, the package `r Biocpkg("pdInfoBuilder") ` can be used to build 
customannotation packages for use with `r Biocpkg("oligo") `. 
In order to do this, PGF / CLF files (called "Library files" on the Affymetrix 
website) as well as the probeset annotations are required. 
The probesets typically represent small stretches 
of the genome (such as a single exon) and multiple probesets
are then used to form a transcript cluster.

The CLF file contains information about the location of
individual probes on the array. The PGF file then contains the individual probe
sequences and shows the probeset they belong to. Finally, the probeset 
annotation .csv then contains information about which probesets are used
in which transcript cluster. Commonly, multiple probesets are used in one
transcript cluster and some probesets are contained in multiple transcript
clusters.


# Linear models

In order to analyse which genes are differentially expressed between 
inflamed and non-inflamed tissue, we have to fit a linear model to our 
expression  data. Linear models are the "workhorse" for the analysis of 
experimental data. They can be used to analyse almost arbitrarily 
complex designs, however they also take a while to learn and understand
and a thorough description is beyond the scope of this workflow.

Mike Love's and Rafael Irizzary's ["Biomedical Data Science"](http://genomicsclass.github.io/book/) [@Irizarry_2015] is a very good resource, especially the section on [interactions and contrasts](http://genomicsclass.github.io/book/pages/interactions_and_contrasts.html).
It might also be helpful to learn some linear algebra to better understand
the concepts here. The Khan Academy offers helpful (and free) [online courses](https://www.khanacademy.org/math/linear-algebra).

## Linear models for microarrays

We now apply linear models to microarrays. Specifically, we discuss
how to use the `r Biocpkg("limma") ` package for differential expression 
analysis. The package is designed to analyze complex experiments involving 
comparisons between many experimental groups simultaneously while remaining 
reasonably easy to use for simple experiments. The main idea is to fit 
a linear model to the expression data for each gene. Empirical Bayes and other 
methods are used to borrow information across genes for the residual variance 
estimation leading to "moderated" \(t\)-statistics, and stabilizing 
the analysis for experiments with just a small number of arrays [@Smyth_2004]. 
Conceptually, the final per gene variance is a mix of a prior variance and 
the per gene variance.

Typical experimental designs are disussed in chapter 9 of `r Biocpkg("limma") `
"User Guide", which can be found on the Bioconductor landing page 
of `r Biocpkg("limma") `. 

In the following, we use appropriate design and contrast matrices for
our linear models and fit a linear model to each gene separately.

## A linear model for the data

For the subsequent linear modelling of the data, we introduce the abbreviations 
"UC" and "CD" for the disease types, and "non_infl." and "infl."
for the phenotypes, respectively: 

```{r introductionOfAbbreviations}
individual <- 
  as.character(Biobase::pData(palmieri_final)$Characteristics.individual.)

tissue <- str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.phenotype.,
                  " ", "_")

tissue <- ifelse(tissue == "non-inflamed_colonic_mucosa",
                 "nI", "I")

disease <- 
  str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.disease.,
                  " ", "_")
disease <- 
  ifelse(str_detect(Biobase::pData(palmieri_final)$Factor.Value.disease., 
                    "Crohn"), "CD", "UC")
```

The original paper is interested in changes in transcription that occur
between inflamed and adjacent non-inflamed mucosal areas of the colon.
This is studied in both inflammatory bowel disease types.

For building our linear model, we have to think about 
which experimental variables we want to consider.
As we want to find differential expression 
between non-inflamed and inflamed tissue, in principle, 
those are the only two variables 
we would have to consider.

However, since we have two arrays per individual patient, we have a
"Paired Samples" design (see section 9.4 of the `r Biocpkg("limma")` 
user guide). This means that the samples might be biased by the person they come 
from. Whenever a feature in an experimental setup 
is expected to have a systematic influence on the result, blocking factors 
on these features should be introduced.

Thus, the first factor we need is a blocking factor for the individuals 
that will absorb differences in expression between
them. Therefore, we block on patients, which means that the 
patient IDs become variables of the linear model.

Then we create factors that give us the grouping for
the tissue types (non-inflamed and inflamed).

Finally, we create two design matrices, 
one for each of the two diseases as we will analyze them separately 
in order to follow the analysis strategy of the original paper 
closely (one could also fit a joint model to 
the complete data set; however, the two diseases might show very different
characteristics so that a joint fit might not be appropriate).

```{r createDesign, eval=TRUE, dependson="excludeMultipleMappings" }
i_CD <- individual[disease == "CD"]
design_palmieri_CD <- model.matrix(~ 0 + tissue[disease == "CD"] + i_CD)
colnames(design_palmieri_CD)[1:2] <- c("I", "nI")
rownames(design_palmieri_CD) <- i_CD 

i_UC <- individual[disease == "UC"]
design_palmieri_UC <- model.matrix(~ 0 + tissue[disease == "UC"] + i_UC )
colnames(design_palmieri_UC)[1:2] <- c("I", "nI")
rownames(design_palmieri_UC) <- i_UC 
```

We can inspect the design matrices:

```{r inspectDesignMatrix, eval = TRUE, dependson="createDesign"}
head(design_palmieri_CD[, 1:6])

head(design_palmieri_UC[, 1:6])
```

In the design matrix, the rows represent the patient array, 
and the columns are the variables we include in our linear model. The variables 
correspond to our blocking factors: there are two for non-inflamed and inflamed 
tissue, respectively, and one for each patient. "`i_UC2424`" for example is the 
blocking variable of patient 2424; UC stands for the disease the patient is 
suffering from. 
For example, the first two rows of the design matrix `design_palmieri_CD` 
correspond to the two arrays for individual "164". 

The design matrix entries are 0 or 1 and thus tell us 
which variables are "active" for which sample: 

It can be seen as a switch that turns the single variables "on" (with a 1 at the 
corresponding position) or "off" (with a 0 at the corresponding position) for 
each row, i. e. each patient array. If we take a closer look at the single rows,
we see that for each sample, there are two "ones" assigned: one to one of the 
variables "nI" or "I" corresponding to the tissue the array came from, 
and one to the corresponding patient-specific blocking variable.

Note that in the linear model, individual 164 serves as the baseline for all 
other individuals and thus isn't included in the sample variables.

Note that instead of blocking on individuals, it would also be possible to use a 
"mixed model" approach with the `duplicateCorrelation()`function from the 
`r Biocpkg("limma")` package. 
It has advantages over the "fixed patient effect model" presented here 
in terms of applicability to more complicated experimental designs, 
where we want to perform comparisons both within and between the patients (e.g. 
comparing between the two diseases; "split-plot-designs"). 

More information on it can be found in the [limma User's Guide](https://www.bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf) (section 17.3.6). 
However, the above explained is more intuitive and is therefore used here.

Before heading on to find all differentially expressed genes for both diseases, 
we will first have a look at how this works in principle for one gene.
We will fit the linear model for one gene and run a t-test in order 
to see whether the gene is differentially expressed or not.

## Analysis of differential expression based on a single gene

For linear model fitting and subsequent testing for differential expression 
by t-test, we will pick the gene with the PROBEID 8164535. It has the gene 
symbol  *CRAT* and will be named as such in the following code. 

**Illustration of the fitted linear model on the *CRAT* gene**

Before fitting the linear model, we have a look at the expression intensities
of this gene for each patient in non-inflamed and inflamed tissue, 
respectively: 


```{r visualizeExpressionChanges, fig.cap="Visualization of expression changes"}
tissue_CD <- tissue[disease == "CD"]
crat_expr <- Biobase::exprs(palmieri_final)["8164535", disease == "CD"]
crat_data <- as.data.frame(crat_expr)
colnames(crat_data)[1] <- "org_value"
crat_data <- mutate(crat_data, individual = i_CD, tissue_CD)

crat_data$tissue_CD <- factor(crat_data$tissue_CD, levels = c("nI", "I"))

ggplot(data = crat_data, aes(x = tissue_CD, y = org_value, 
                             group = individual, color = individual)) +
      geom_line() +
      ggtitle("Expression changes for the CRAT gene")
```

We see that overall, this gene is expressed less in inflamed tissue 
(Figure \@ref(fig:visualizeExpressionChanges)). We also see that the absolute 
expression intensities vary greatly between patients. 
However, we have already taken care of this 
problem by introducing blocking factors based on the individuals, which allows 
us to compare the tissues within each individual as represented by
the single lines.

If we had not blocked for individuals, the linear model would 
treat them interchangably and a graphical depiction would only
include a single line. Since the individuals haver very different
baseline expression levels, this would lead to a very high variance of
the estimated fold changes.

We now compute the variable coefficients by fitting a linear model. 
We get a vector `crat_coef` with one entry for each variable.

```{r obtainFitCRAT}
crat_coef <- lmFit(palmieri_final[,disease == "CD"],
                design = design_palmieri_CD)$coefficients["8164535",]

crat_coef
```


In order to now obtain the expression values fitted by the model, 
we multiply the design matrix with this vector of coefficients `crat_coef`:

```{r 2obtainFitCRAT}
crat_fitted <- design_palmieri_CD %*% crat_coef
rownames(crat_fitted) <- names(crat_expr)
colnames(crat_fitted) <- "fitted_value"

crat_fitted
```

Recall that for every row in the design matrix (i.e. every patient sample) 
only the variables with a 1 in the design matrix are taken into account for 
calculating the fitted expression value. 

This means that as output of the multiplication, we get 
a vector `crat_fitted` whose entries are the sum of relevant 
variable coefficients for each sample, respectively.

For example, the fitted value for patient sample `2114_I.CEL` 
is `r crat_coef["nI"] + crat_coef["i_CD2114"]`: it is the sum of the respective activated variable coefficients "nI" (`r crat_coef["nI"]`) 
and "i_CD2114" (`r crat_coef["i_CD2114"]`).


Let's visualize the difference between non-inflamed and inflamed tissue 
again after fitting: 

```{r 3obtainFitCRAT, fig.cap="Expression changes for the CRAT gene"}
crat_data$fitted_value <- crat_fitted

ggplot(data = crat_data, aes(x = tissue_CD, y = fitted_value, 
                             group = individual, color = individual)) +
      geom_line() +
      ggtitle("Fitted expression changes for the CRAT gene")
```


Note that the difference of the fitted expression values between inflamed and 
non-inflamed samples of one patient is the same for all patients and 
is determined by the difference between the variable coefficients of 
`I` (`r crat_coef["I"]`) and `nI` (`r crat_coef["nI"]`), 
which is  `r crat_coef["I"] - crat_coef["nI"]` 
(Figure \@ref(fig:3obtainFitCRAT)). 

This is the case because the same blocking variable is activated by the design 
matrix for both samples from a single patient, leading to a comparison within
patients only. These blocking variables correct the fitted tissue specific 
expression values towards the expression levels of the individual patients.
Therefore the final estimate is like an average of all the within-individual
differences.

The "difference" between non-inflamed and inflamed tissue of 
`r crat_coef["I"] -  crat_coef["nI"]` is actually a log2 fold change, as our 
expression data is on the log2 scale. `r crat_coef["I"] - crat_coef["nI"]`
therefore is our log2 fold change for the CRAT gene.

**Differential expression analysis of the CRAT gene**

In order to test whether the gene is differentially expressed or not, 
a \(t\)-test with the null hypothesis that there is no difference 
in the expression between non-inflamed and inflamed tissue is carried out. 
Our blocking design is conceptually similar to a paired t-test for 
which the statistic is given by:


\[
 t = \frac{\bar{d} }{s/\sqrt{n}}
\]

Where, \(\bar{d}\) is the mean difference in expression values
between the individuals. 
The paired t-test computes the variance \(s^2\) from the paired differences.
This is lower than the variance of a standard t-test and thus the paired 
t-test has higher power as long as the expression values 
for the same individual are correlated ([see e.g. the article on Wikipedia](https://en.wikipedia.org/wiki/Paired_difference_test)).

We thus have improved the power of the ordinary \(t\)-test 
by reducing the variance via blocking on individuals.

We now conduct the \(t\)-test on the linear model in order to find 
out whether the difference between non-inflamed and inflamed 
tissue differs significantly from 0: 

```{r tTest}
crat_noninflamed <- na.exclude(crat_data$org_value[tissue == "nI"])
crat_inflamed <- na.exclude(crat_data$org_value[tissue == "I"])
res_t <- t.test(crat_noninflamed ,crat_inflamed , paired = TRUE)
res_t
```

We get a low p-value close to `r round(res_t[["p.value"]], 4) `
and thus can conclude that the *CRAT* gene is differentially 
expressed between non-inflamed and inflamed tissue.

Note that the p-value isn't exactly the same one as below when analyzing the 
differential expression of all genes. This is due to the variance moderation 
performed by `r Biocpkg("limma")` .

## Contrasts and hypotheses tests

We now fit the linear model for all genes and
define appropriate contrasts to test hypotheses of interest.

We want to compare the inflamed to the non-inflamed tissue.
Thus, we create a contrast matrix consisting of only one contrast "I-nI": 
`r Biocpkg("limma")`'s function
`makeContrasts` creates this matrix from 
a symbolic description of the contrast of
interest.

We now fit a linear model to our data and apply the `contrasts.fit()` function 
to it in order to find genes with significant differential expression between non-inflamed and inflamed tissue:



```{r createContrastMatrixAndFitModel, eval=TRUE, dependson="createDesign" }
contrast_matrix_CD <- makeContrasts(I-nI, levels = design_palmieri_CD)

palmieri_fit_CD <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "CD"],
                                design = design_palmieri_CD),
                                contrast_matrix_CD))

contrast_matrix_UC <- makeContrasts(I-nI, levels = design_palmieri_UC)

palmieri_fit_UC <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "UC"],
                                design = design_palmieri_UC),
                                contrast_matrix_UC))
```

We applied the empirical Bayes variance moderation method to the model 
via the `eBayes()` function, which
computes moderated \(t\)-statistics. In microarray analysis, 
the number of arrays often is quite small, 
and thus variance estimation is difficult.
Using a combination of the per-gene-variance 
and a prior variance we can improve the 
variance estimate, hence the term "moderation". "Empirical Bayes" 
means that the prior is estimated from the data.

The result of the `eBayes()` step is that the individual variances are
shrunken towards the prior value. 

## Extracting results

Finally, we extract the number of differentially expressed genes. 
Results can be extracted by use of the `topTable` function. 
We extract the results for both Crohn's disease and ulcerative colitis, and the 
results are sorted by their absolute \(t\)-statistics.
As a diagnostic check, we also plot the p-value histogram: We expect a uniform 
distribution for the p-values that correspond to true null hypotheses, while 
a peak near zero shows an enrichment for low p-values corresponding to differentially 
expressed (DE) genes.
 
Note that if the p-value distribution for a dataset is very different 
from the ones in the histograms below, this might lead to quality loss in the 
subsequent analysis. Reasons for a divergent p-value-distribution might be
batch effects or a lack of consideration of other blocking factors in the design 
matrix. Thus, if the p-value is not as expected, 
try to include possible blocking factors and batches and rerun the analysis. 
If this does not help, empirical Bayes / null estimation methods 
for multiple testing are useful. 

A good starting point to learn about these methods is the article on 
false discovery rate estimation by Korbininan Strimmer [@Strimmer_2008] 
and chapter 1--6 of Efron's book on Large-Scale Inference [@Efron_2010], 
as well as the blog-post on "How to interpret a p-value histogram" by David 
Robinson [@Robinson_2014].

```{r extractResultsCD, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for Crohn’s disease."}
table_CD <- topTable(palmieri_fit_CD, number = Inf)
head(table_CD)

hist(table_CD$P.Value, col = brewer.pal(3, name = "Set2")[1],
     main = "inflamed vs non-inflamed - Crohn's disease", xlab = "p-values")

```

```{r extractResultsUC, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for ulcerative colitis."}

table_UC <- topTable(palmieri_fit_UC, number = Inf)
head(table_UC)

hist(table_UC$P.Value, col = brewer.pal(3, name = "Set2")[2],
     main = "inflamed vs non-inflamed - Ulcerative colitis", xlab = "p-values")

```

## Multiple testing FDR, and comparison with results from the original paper

In the original paper, a p-value of 0.001 was used as a significance
cutoff. Using this we get `r nrow(subset(table_UC, P.Value < 0.001))`
genes identified as differentially expressed for UC:


```{r pCutForCD}
nrow(subset(table_UC, P.Value < 0.001))
```


However, it is impossible
to determine a precise bound on the number of false positive genes
in this list. All that we can say using p-values is that we have 
at most `r nrow(table_UC)` (total number of tests) * 0.001
= `r nrow(table_UC)* 0.001` false positive genes in our list. Therefore, 
by choosing a p-value cutoff of 0.001, as much as
`r round(nrow(table_UC)* 0.001 / nrow(subset(table_UC, P.Value < 0.001))*100, 2)`% 
of our genes
identified as differentially expressed might be false positives. 

Thus, we can see that the "raw" p-values are very "liberal" when
looking at many tests simultaneously. We therefore need error
rates adapted to the multiple testing situation. By far the 
most popular one in molecular biology is the **false discovery
rate** or FDR for short. It is the percentage of false positives 
among all positives. As we have seen, the FDR of our genes list
using a simple p-value cutoff might be quite high.

On the other hand, we can see a clear peak in the p-value histogram 
(Figure \@ref(fig:extractResultsUC)), caused by the differentially
expressed genes. There we expect the actual FDR of our list 
to be lower.

The FDR at a given cutoff is given by the "adjusted" p-value in
the results table.

```{r FDRforUC}
tail(subset(table_UC, P.Value < 0.001))
```

The adjusted p-value for a raw p-value of 0.001 in 
the table is `r max(subset(table_UC, P.Value < 0.001)$adj.P.Val)`,
which is an order of magnitude lower than the FDR we can infer 
from p-values alone.

So although this is not recommended in general,
we also use a p-value cutoff at 0.001 in the following
in order to be able to compare our workflow results to the paper results. 

The paper results can be downloaded as excel files from
[http://links.lww.com/IBD/A795](http://links.lww.com/IBD/A795) and 
should be saved as an .xlsx file named `palmieri_DE_res.xlsx` in 
your working directory. 

Note that while the paper uses p-value cutoffs, it also reports the
corresponding FDRs (just as we did for the UC data here).

For a p-value cutoff of 0.001, the corresponding FDRs are 0.05 in 
Crohn's disease  and 0.02 in ulcerative colitis. There are four tables in total, 
giving the list of up and downregulated genes in CD and UC, respectively.
We calculate the overlap between our results and the ones from the 
paper as the ratio of the genes that were found in both analyses 
and the genes that were only found in the paper.

We also calculate the total number of diffentially expressed
genes that we find in our workflow analysis.
 
```{r compareDEgenes, dependson=c("extractResultsUC", "extractResultsCD")}
fpath <- system.file("extdata", "palmieri_DE_res.xlsx", package = "maEndToEnd")
palmieri_DE_res <- sapply(1:4, function(i) read.xlsx(cols = 1, fpath, 
                                                     sheet = i, startRow = 4))

names(palmieri_DE_res) <- c("CD_UP", "CD_DOWN", "UC_UP", "UC_DOWN")
palmieri_DE_res <- lapply(palmieri_DE_res, as.character)
paper_DE_genes_CD <- Reduce("c", palmieri_DE_res[1:2])
paper_DE_genes_UC <- Reduce("c", palmieri_DE_res[3:4])

overlap_CD <- length(intersect(subset(table_CD, P.Value < 0.001)$SYMBOL,  
                               paper_DE_genes_CD)) / length(paper_DE_genes_CD)


overlap_UC <- length(intersect(subset(table_UC, P.Value < 0.001)$SYMBOL,
                               paper_DE_genes_UC)) / length(paper_DE_genes_UC)
overlap_CD
overlap_UC 

total_genenumber_CD <- length(subset(table_CD, P.Value < 0.001)$SYMBOL)
total_genenumber_UC <- length(subset(table_UC, P.Value < 0.001)$SYMBOL)

total_genenumber_CD
total_genenumber_UC
```

We find `r total_genenumber_CD` (CD) and `r total_genenumber_UC` (UC) 
differentially expressed genes ("DE-genes").

In the paper, 298 (CD) and 520 (UC) DE-genes were found for the two diseases 
at the same cutoff. This higher number of DE-genes identified is probably
due to the increased power of the blocking according to the individuals
and the moderated variance estimation that `r Biocpkg("limma") ` performs.

We see that we get a moderate overlap of `r overlap_CD` for CD and
`r overlap_UC` for UC, showing that both analyses lead to
somewhat comparable results. 

## Visualization of DE analysis results - volcano plot

For a visualization of the differentially expressed genes, we create a volcano 
plot, which is commonly used to summarize the results of a differential expression analysis in a single figure.

For a better overview, we only show gene symbols of genes with 
a fold change greater than 1, which we define in the `volcano_names` object. The 
`highlight` option in the `volcanoplot` function is set to 100 and thus only 
labels the 100 genes with the lowest p-values. 

```{r VolcanoPlot, fig.cap="Volcano plot of the DE-genes", fig.height=8, fig.width=7}

volcano_names <- ifelse(abs(palmieri_fit_CD$coefficients)>=1, 
                        palmieri_fit_CD$genes$SYMBOL, NA)
             
             
volcanoplot(palmieri_fit_CD, coef = 1L, style = "p-value", highlight = 100, 
            names = volcano_names,
            xlab = "Log2 Fold Change", ylab = NULL, pch=16, cex=0.35)
```

We can now do a little research on the biological function of genes that show a
high foldchange, for example the gene with the symbol S100A8 on the right side
of the plot (Figure \@ref(fig:VolcanoPlot)). If we search for this gene symbol on
[genecards.org](https://www.genecards.org), we find that it encodes for a
protein that builds a pro-inflammatory complex in association with another
protein.

# Gene ontology (GO) based enrichment analysis

As discussed above, it is recommended to use an FDR cutoff in differential 
expression analysis rather than a p-value cutoff, 
since this way you control an explicitly defined error rate 
and the results are easier to interpret and
to compare. For the following enrichment analysis, we create tables with 
differentially expressed genes for CD and UC, respectively, 
and choose an FDR cutoff of 10\%. Here, we focus on the CD subset of the data.


```{r FDRcontrolledDEgenes, dependson=c("extractResultsUC", "extractResultsCD"), eval=TRUE}
DE_genes_CD <- subset(table_CD, adj.P.Val < 0.1)$PROBEID
```

We can now try to characterize the identified differentially expressed genes
more in detail by performing a GO enrichment analysis. Essentially the
gene ontology ([http://www.geneontology.org/](http://www.geneontology.org/)) is 
a hierarchically organized collection of functional gene sets
[@Ashburner_2000; @GO_2015; @du_Plessis_2011]. 

## Matching the background set of genes

The function ` genefinder ` from the `r Biocpkg("genefilter") ` 
package [@Bourgon_2010] 
will be used to find a background set of genes that are similar in expression 
to the differentially expressed genes. We then check whether 
the background has roughly the same distribution
of average expression strength as the foreground.

We do this in order not to select a biased background since the gene set testing
is performed by a simple Fisher test on a 2x2 table. Note that this approach
is very similar to commonly used web tools like GOrilla [@Eden_2009]. 

For every differentially expressed gene, we try to find genes with similar
expression with `genefinder`. The `genefinder` function returns a list with two 
elements for each gene: one with the indices of the 
background genes found and one with the distances to the DE-genes:

```{r GOAnalysisCreateBackgrounds, eval=TRUE, warning=FALSE, message=FALSE}
back_genes_idx <- genefilter::genefinder(palmieri_final, 
                                        as.character(DE_genes_CD), 
                                        method = "manhattan", scale = "none")
```

We have to extract the PROBEIDs, which correspond to the indices. 
We do that by using the `sapply` 
function, which gives us a single matrix with the DE-genes as column names 
and the  PROBEIDs of the corresponding background genes in the cells below:

```{r GOAnalysisCreateBackgrounds2, eval=TRUE, warning=FALSE, message=FALSE}
back_genes_idx <- sapply(back_genes_idx, function(x)x$indices)
```

We then create a vector `back_genes` containing all background gene PROBEIDs:



In order to eliminate foreground genes, i.e. DE-genes, from the `back_genes` 
set, we use the `setdiff` function. It returns all elements from the first 
argument (`back_genes`) that are not part of the second argument 
(`DE_genes_CD`). 
With the `intersect` function, we verify that we were successful: 
it should return 0, as there shouldn't be any intersect anymore between
`back_genes`and `DE_genes_CD`:

```{r GOAnalysisCreateBackgrounds3, eval=TRUE, warning=FALSE, message=FALSE}
back_genes <- featureNames(palmieri_final)[back_genes_idx]
back_genes <- setdiff(back_genes, DE_genes_CD)

    
intersect(back_genes, DE_genes_CD)
length(back_genes)
```

We create a multidensity plot with mean expression on the x-axis 
and curves for all genes, foreground genes and background genes, respectively 
(Figure \@ref(fig:multidensityPlot)). We want to see whether the background 
genes show a plot similar to the foreground genes so that the background 
is not biased for the gene enrichment analysis:

```{r multidensityPlot, fig.cap="Selecting a background set of genes for the gene ontology analysis."}
multidensity(list(
        all = table_CD[,"AveExpr"] ,
        fore = table_CD[DE_genes_CD , "AveExpr"],
        back = table_CD[rownames(table_CD) %in% back_genes, "AveExpr"]),
        col = c("#e46981", "#ae7ee2", "#a7ad4a"),
     xlab = "mean expression",
   main = "DE genes for CD-background-matching")
```

When comparing the "background gene" curve to the "foreground gene" curve, 
we see a  similar curve shape, indicating a sensible background matching 
(Figure \@ref(fig:multidensityPlot)). Note that the right-shift of the 
"foreground-gene" curve in comparison to the "background-gene" curve 
indicates that DE-genes are generally very
highly expressed, so that it wasn't possible to find background-genes 
with exactly equal overall expression distribution.

The "all gene" curve has the leftmost curve maximum; 
this can be explained by a high number of lowly expressed genes 
in all samples and shows that a background matching is sensible 
in order to avoid biases.

For the actual testing of which GO gene sets are enriched in inflamed tissue, 
we use the `r Biocpkg("topGO")` package which implements a nice interface 
to Fisher testing and also has additional algorithms
taking the GO structure into account, by e.g. only reporting the most specific
gene set in the hierarchy [@Alexa_2006].

The GO has three top ontologies: Cellular component (CC), biological processes
(BP), and molecular function (MF). For illustrative purposes we limit ourselves 
to the BP category here. 

## Running topGO

topGO requires a topGOdata object containing the necessary information for the 
analysis. We follow the steps described in the topGO vignettes: First, 
we will create a named vector `all_genes` with all genes to be analyzed, i.e. 
DE-genes and background genes: 

```{r createFactorOfInterestingGenes, dependson="GOAnalysisCreateBackgrounds", eval=TRUE}
gene_IDs <- rownames(table_CD)
in_universe <- gene_IDs %in% c(DE_genes_CD, back_genes)
in_selection <- gene_IDs %in% DE_genes_CD 

all_genes <- in_selection[in_universe]
all_genes <- factor(as.integer(in_selection[in_universe]))
names(all_genes) <- gene_IDs[in_universe] 
```

The following steps were carried through: 

  1. we created an `in_universe` vector by using the `%in%` matching function. 
  We want to know which elements from `gene_IDs` are also contained in 
  `DE_genes_CD` and `back_genes`, as the latter two are our gene universe 
  we use for enrichment analysis.
  We got a vector `in_universe` with the length of `gene_IDs` that has the 
  entry `TRUE` when the corresponding gene in `gene_IDs` could be also found in 
  `DE_genes_CD` or `back_genes`, and `FALSE` otherwise.
  
  2. We did the same for our DE-genes and call this vector `in_selection`.
  
  3. We created the `all_genes` vector:
    a) First, we selected all the elements from `in_selection` 
    that are `TRUE` in `in_universe` by applying
    `all_genes <- in_selection[in_universe]`.
    b) Then, we converted the elements in `all_genes` from `TRUE` and `FALSE` 
    to 0 and 1 by converting the vector to an integer vector. 
    This way, each element in the vector is a 0 if the corresponding gene is a
    background gene and a 1 if the corresponding gene is a DE-gene. Also, we 
    converted the vector to a factor.
    c) We named the vector elements with the corresponding `gene_IDs`.


We now initialize the `r Biocpkg("topGO") ` data set, using the GO annotations 
contained in the annotation data base for the chip we are using. The `nodeSize`
parameter specifies a minimum size of a GO category we want to use: i.e. here,
categories with less than 10 genes are not included in the testing.

```{r createTopGODataSet, dependson="createFactorOfInterestingGenes", eval=TRUE, message = FALSE, warning=FALSE}
top_GO_data <- new("topGOdata", ontology = "BP", allGenes = all_genes,
 nodeSize = 10, annot = annFUN.db, affyLib = "hugene10sttranscriptcluster.db")
```

Now the tests can be run. `r Biocpkg("topGO") ` offers a wide range of options,
for details see the paper [@Alexa_2006] or the package vignette.

We run two common tests: an ordinary Fisher test for every GO category, and the
"elim" algorithm, which tries to incorporate the hierarchical structure of the
GO and tries to "decorrelate" it in order to report the most specific 
significant term in the hierarchy.

The algorithm starts processing the nodes / GO categories
from the highest (bottommost) level and then iteratively
moves to nodes from a lower level. If a node is scored as significant,
all of its genes are marked as removed in all ancestor nodes.
This way, the "elim" algorithm aims at finding the most specific node
for every gene.

The test uses a 0.01 p-value cutoff by default.

```{r runtopGOTests, results='hide', eval=TRUE, dependson = "createTopGODataSet", message = FALSE}
result_top_GO_elim <- 
  runTest(top_GO_data, algorithm = "elim", statistic = "Fisher")
result_top_GO_classic <- 
  runTest(top_GO_data, algorithm = "classic", statistic = "Fisher")
```

We can now inspect the results. We look at the top 100 GO categories according
to the "Fisher elim" algorithm. The function `GenTable` produces
a table of significant GO categories, the function `printGenes`
gives genes annotated to them; the significant ones are denoted with a "2"
in the "raw  p-value" column, the non-significant ones with a "1". 
We therefore select `raw p-value == 2`. 

Note that we do not get the actual p-values here because our `all_genes` vector 
doesn't contain this information; it only tells us
whether a gene is differentially  expressed or not.

```{r processtopGOResults, eval=TRUE, dependson="runtopGOTests"}
res_top_GO <- GenTable(top_GO_data, Fisher.elim = result_top_GO_elim,
        Fisher.classic = result_top_GO_classic,
        orderBy = "Fisher.elim" , topNodes = 100)

genes_top_GO <- printGenes(top_GO_data, whichTerms = res_top_GO$GO.ID,
    chip = "hugene10sttranscriptcluster.db", geneCutOff = 1000)

res_top_GO$sig_genes <- sapply(genes_top_GO, function(x){
                str_c(paste0(x[x$'raw p-value' == 2, "Symbol.id"],";"), 
                      collapse = "")
    })

head(res_top_GO[,1:8], 20)
```

## Visualization of the GO-analysis results

A graph of the results can also be produced. Here we visualize the three most
significant nodes according to the Fisher elim algorithm in the context of
the GO hierarchy.


```{r graphOfResults, fig.height = 6, eval=TRUE, results='hide', dpi=600, fig.cap="Significantly enriched GO nodes in the GO hierarchy"}
showSigOfNodes(top_GO_data, score(result_top_GO_elim), firstSigNodes = 3,
               useInfo = 'def')
```

We can see that indeed GO categories related to inflammation, signalling and 
immune response come up as significant (Figure \@ref(fig:graphOfResults))
Gene set enrichment analysis has been a field of very extensive
research in bioinformatics. For additional approaches
see the `r Biocpkg("topGO") ` vignette and the references therein 
and also in the [GeneSetEnrichment view](http://bioconductor.org/packages/release/BiocViews.html#___GeneSetEnrichment). 


# A pathway enrichment analysis using reactome

The package `r Biocpkg("ReactomePA") ` offers the possibility to test enrichment
of specific pathways using the free, open-source, curated and peer reviewed 
[Reactome](http://www.reactome.org/) pathway database [@Croft_2013; @Fabregat_2017]. 
The package requires entrez identifiers, so we convert our PROBEIDs 
(transcript cluster identifiers) to entrez identifiers 
using the function `mapIDs` from the package `r Biocpkg("AnnotationDbi")`. 
This will create a named vector that maps the PROBEIDs to the entrez ones, 
with the PROBEIDs as names and the entrez ids as vector elements.


```{r mapIDsToEntrez, dependson="createFactorOfInterestingGenes", message = FALSE}
entrez_ids <- mapIds(hugene10sttranscriptcluster.db, 
      keys = rownames(table_CD), 
      keytype = "PROBEID",
      column = "ENTREZID")
```

We can now run the enrichment analysis that performs a statistical test
based on the hypergeoemtric distribution that is the same as a one sided 
Fisher-test, which `r Biocpkg("topGO")` calls "Fisher-classic".
Details can be found in the vignette of the `r Biocpkg("DOSE")` 
package [@Yu_2014].

```{r runReactomeEnrichment, fig.cap="Enriched Reactome pathways and their p–values as a bar chart.", eval = TRUE, warning=FALSE}
reactome_enrich <- enrichPathway(gene = entrez_ids[DE_genes_CD], 
                                universe = entrez_ids[c(DE_genes_CD, 
                                                        back_genes)],
                                organism = "human",
                                pvalueCutoff = 0.05,
                                qvalueCutoff = 0.9, 
                                readable = TRUE)

reactome_enrich@result$Description <- paste0(str_sub(
                                    reactome_enrich@result$Description, 1, 20),
                                    "...")

head(as.data.frame(reactome_enrich))[1:6]
```

Note that we trimmed pathway names to 20 characters.

## Visualizing the reactome based analysis results 

The top pathways can be displayed as a bar chart that displays all categories
with a p-value below the specified cutoff (Figure \@ref(fig:reactomeBar)).

```{r reactomeBar, dependson="runReactomeEnrichment", fig.cap="Enriched Reactome pathways and their p–values as a bar chart."}
barplot(reactome_enrich)
```

The "enrichment map" from the package `r Biocpkg("enrichplot")` 
displays the results of the enrichment analysis as 
a graph, where the color represents the p-value of the pathway and the
edge-thickness (that is the line connecting two pathways) is proportional 
to the number of overlapping genes between two pathways.

```{r emapplot, dependson="runReactomeEnrichment", fig.width=6, fig.height = 7, fig.cap="Enriched Reactome pathways enrichment results as a graph."}
emapplot(reactome_enrich, showCategory = 10)
```

Again, the graph in Figure \@ref(fig:emapplot) shows pathways related 
to signalling and immune response. 

The package `r Biocpkg("clusterProfiler") ` [@Yu_2012] can also perform these 
analyses using downloaded KEGG data. Furthermore, 
the package `r Biocpkg("EnrichmentBrowser")`
[@Geistlinger_2016] additionally offers network-based enrichment analysis of individual 
pathways. This allows the mapping of the expression data at hand to known
regulatory interactions.


# Session information

As the last part of this document, we call the function *sessionInfo*,
which reports the version numbers of R and all the packages used in
this session. It is good practice to always keep such a record of this
as it will help to track down what has happened in case an R script
ceases to work or gives different results because the functions have
been changed in a newer version of one of your packages. By including
it at the bottom of a script, your reports will become more reproducible.

The session information should also *always*
be included in any emails to the
[Bioconductor support site](https://support.bioconductor.org) along
with all code used in the analysis.

```{r}
gc()

length(getLoadedDLLs())

sessionInfo()
```


# Acknowledgements

The authors would like to thank Vladislava Milchevskaya, 
Julian Gehring and Mike Smith for helpful comments on and small contributions 
to the workflow. They also would like to thank Frederik Ziebell, Holly Giles and 
Jennifer Huellein for proof-reading.

This workflow draws a lot of inspiration from the Bioconductor 
books [@Bioc2005; @useRbook2008] as well as Love et. al.'s workflow 
for gene level analysis of RNA-Seq data [@Love_2016]. James W. MacDonald 
provided valuable information on the evolution of Affymetrix arrays in some of 
his posts of on the Biocondctor support site. 
BK would also like to thank him for some friendly personal 
correspondence about the annotation resources available
for microarrays in Bioconductor.



# Author Contributions

BK produced the first version of this article. 
BK implemented the main scaffold of the workflow and designed 
the workflow steps. SR implemented additional workflow steps and 
improved existing ones from version 1. BK and SR wrote the article.


# References

