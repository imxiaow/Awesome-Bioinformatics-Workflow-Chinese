---
title: "An end to end workflow for differential gene expression using Affymetrix microarrays"
author: 
  - name: Bernd Klaus
    affiliation: EMBL Heidelberg, Meyerhofstrasse 1, 69117 Heidelberg, Germany, bernd.klaus@embl.de
  - name: Stefanie Reisenauer
    affiliation: EMBL Heidelberg, Meyerhofstrasse 1, 69117 Heidelberg, Germany, steffi.reisenauer@tum.de
header-includes:
  - \usepackage{float}
摘要: 在这篇文章里，我们将阐述用 Bioconductor 包 an end-to-end Affymetrix microarray differential expression 的工作流程。这个工作流程可以直接应用在目前 “基因” 类型的微陈列，例如 HuGene 或 MoGene 微陈列，同时也容易调整并适用于类似的平台。在这里进行分析的数据是来自典型的临床微陈列数据集，用来对比两种疾病亚型中发炎和非发炎的结肠组织。针对每种疾病，发炎和非发炎的结肠组织的差异基因表达被进行了分析。我们将从原始数据 CEL 文件开始，展示如何将其导入为 Bioconductor 的 ExpressionSet，实施质量控制和归一化和最终的差异基因表达分析，其次是一些显著性分析。
keywords: Microarray, Gene Expression
bibliography: MAEndToEnd.bib
output:
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
csl: f1000-research.csl
date: 14 September 2018
vignette: >
  %\VignetteIndexEntry{An end to end workflow for differential gene expression using Affymetrix microarrays}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---
<!-- latest version from github -->
<!-- devtools::install_github("b-klaus/maEndToEnd", ref = "master") -->

<!--Html rendering for Bioc Workflow using BiocStyle-->
<!-- rmarkdown::render("MA-Workflow.Rmd") -->


<!-- pdf rendering using to F1000 template from Mike's BiocWorkflowTools  -->
<!-- also keeps .tex files for overleaf submission -->
<!-- rmarkdown::render("MA-Workflow.Rmd", output_format = BiocWorkflowTools::f1000_article(keep_tex = TRUE)) -->

<!-- command to compile the vignette using Rscript to check the mem usage -->
<!-- Rscript --vanilla test_mem.R -->


<!--  Conversions between f1000 / BioStyle by Leo Torres -->
<!-- https://stat.ethz.ch/pipermail/bioc-devel/2018-April/013237.html -->
<!-- His example recount workflow that compiles to both BioC and F1000  -->
<!-- https://github.com/LieberInstitute/recountWorkflow/blob/master/vignettes/recount-workflow.Rmd -->



```{r biocSetup, include = FALSE, results="hide", warning=FALSE, echo=FALSE}
## Changing the YAML to the following changes the output to 'latex'
## output:
## BiocWorkflowTools::f1000_article
## More at:
## https://stackoverflow.com/questions/35144130/in-knitr-how-can-i-test-for-if-the-output-will-be-pdf-or-word

## add figures to current directory if Rmd is converted to LaTeX
## This simplifies processing on overleaf

if (!is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))) {
    
    to_html <- knitr::opts_knit$get("rmarkdown.pandoc.to") != 'latex'
        if (!to_html) {
          knitr::opts_chunk$set(fig.path = "", out.width = '.8\\linewidth')
        } 

}
## here, pdf specific adapations can be made
## however, the option "rmarkdown.pandoc.to" is only set by rmarkdown::render,
## so it returns NULL if run interactively!

```

```{r testAlternativeToChunkAbove, eval=FALSE, include=FALSE, echo=FALSE}
# this does not work as it will only test the output formats
# specified in the YAML header
any(grepl("f1000", rmarkdown::all_output_formats(knitr::current_input()))) 
```


```{r knitrOptions, include=FALSE}
library(BiocStyle)
library(knitr)
options(digits = 4, width = 80)
opts_chunk$set(echo = TRUE, 
               tidy = FALSE, 
               include = TRUE,
               dev = c('png'),
               fig.width = 6, fig.height = 3.5,
               comment = '  ', 
               dpi = 300, cache = TRUE,
               fig.pos = "H")

```


<p>
**R 版本**: `r R.version.string`
<br />
**Bioconductor 版本**: `r BiocManager::version()`
<br />
**包版本**: `r packageVersion("maEndToEnd")`
</p>


# 介绍

在这篇文章里我们将介绍典型的（Affymetrix）微阵列分析的完整
工作流程。从数据导入，前期处理，差异基因表达和显著性分析都会
被讨论。

使用的数据 [@Palmieri_2015] 来自于一篇研究发炎和非发炎组
织中差异基因表达的论文。
测试了 14 个患有溃疡性结肠炎 (UC)的病人和 15 个患有克罗恩病
（CD) 的病人，然后通过活检提取了每个病人发炎和未发炎的结肠粘
膜组织。
这个典型的临床数据集共由 58 个阵列构成。我们的目标是分析组织
间的差异表达（DE）。
我们的结果显示了与原始论文结果的大量重叠。

# 工作流程包的安装

工作流程被包裹在叫做 `maEndToEnd` 的包里。

`maEndToEnd` 包目前可以从 GitHub 获得，
目前可用的开发版本为 Bioconductor (3.8) (看这里:<http://bioconductor.org/packages/devel/workflows/html/maEndToEnd.html>).

## 从 Bioconductor 安装工作流程包

你可以通过 `r CRANpkg("BiocManager")`安装包。

```{r installBioc, eval=FALSE}
if (!require("BiocManager"))
    install.packages("BiocManager")
BiocManager::install("maEndToEnd", version = "devel")
```

目前，工作流程可在 Bioconductor（3.8）的开发版本中获得， 这将
成为 2018 年 10 月的发布版本。

有关如何使用这个版本 Bioconductor 的详细信息见：

<http://bioconductor.org/developers/how-to/useDevel/>

## 从 Github 安装工作流程包

```{r, echo=TRUE, results="hide", warning=FALSE, eval=FALSE}

#为了从 GitHub下载包，我们需要来自 “remotes” 的包里中 
#“install_github”的功能。我们用 
#devtool::install_github 从 GitHub下载了最新的开发
#版本的 "remotes" 函数；注意：这是必要的。
#目前在CRAN上面的 “remotes” 版本不允许我们正确的下载 "maEndToEnd"包：

install.packages("devtools")
library(devtools)

devtools::install_github("r-lib/remotes")
library(remotes)
packageVersion("remotes") # has to be 1.1.1.9000 or later

remotes::install_github("b-klaus/maEndToEnd", ref="master")

```

## 工作流程包的导入

成功安装工作流程包后，
我们可以使用对library() 的调用来加载它。
它还将加载运行工作流程所需的所有其他包。

```{r maEndToEndImport}
suppressPackageStartupMessages({library("maEndToEnd")})
```

## 工作流程所需要的包列表

下面，您可以找到工作流程所需的软件包列表。
这里已经注释了一些 Helper/Styling 包，
它们不是执行工作流所必需的。

```{r pkgList, results="hide"}
#通常的 Bioconductor 包
    library(Biobase)
    library(oligoClasses)
     
#注释和数据导入包
    library(ArrayExpress)
    library(pd.hugene.1.0.st.v1)
    library(hugene10sttranscriptcluster.db)
     
#质量控制和前期处理包
    library(oligo)
    library(arrayQualityMetrics)
     
#分析和统计包
    library(limma)
    library(topGO)
    library(ReactomePA)
    library(clusterProfiler)
     
#绘图和颜色选项包
    library(gplots)
    library(ggplot2)
    library(geneplotter)
    library(RColorBrewer)
    library(pheatmap)
     
#格式化/文档包
   #library(rmarkdown)
   #library(BiocStyle)
    library(dplyr)
    library(tidyr)

#助手包 (Helpers)
    library(stringr)
    library(matrixStats)
    library(genefilter)
    library(openxlsx)
   #library(devtools)

```


# 从 ArrayExpress 下载原始数据

分析的第一步是下载原始数据CEL文件。
这些文件由阵列扫描仪软件生成，包含测量的探针强度。我们使用的数据已存放在 [ArrayExpress](https://www.ebi.ac.uk/arrayexpress/) 上，
其登记号为 **E-MTAB-2967**.

我们将这些文件存储在 **raw\_data\_dir** 目录中，
该目录默认为临时目录。

```{r generateFolderForRawData}
raw_data_dir <- tempdir()

if (!dir.exists(raw_data_dir)) {
    dir.create(raw_data_dir)
}

```


每个 ArrayExpress 数据集都有一个总结数据集的登陆页面， 
我们使用`r Biocpkg("ArrayExpress") ` Bioconductor 包中的 `getAE` 函数获取原始数据文件的
ftp 链接 ([Data from Palmieri et. al. on ArrayEpress](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2967/)).


使用下面的代码，我们使用`getAE`函数
从 [ArrayExpress](https://www.ebi.ac.uk/arrayexpress/) [@Kolesnikov_2014] 下载原始数据（也包括注释数据）。
数据保存在上面创建的  `raw_data_dir`中。
下载文件的名称将作为列表返回。


```{r getDataEBI, eval=TRUE, results='hide', message=FALSE}
anno_AE <- getAE("E-MTAB-2967", path = raw_data_dir, type = "raw")
```

我们现在将仔细研究从 ArrayExpress 下载的数据。

# 有关数据的背景信息

## ArrayExpress 里储存的信息

ArrayExpress 中的每个数据集都根据 
MAGE-TAB（微阵列基因表达式表格）规范存储为与
原始数据捆绑在一起的表的集合。  
MAGE-TAB 格式指定最多五种不同类型的文件：


* **调查说明格式 (IDF)**
* **阵列设计格式 (ADF)**
* **样本和数据关系格式 (SDRF)**
* **原始数据文件** 
* **处理过的数据文件**

除原始数据文件外，
IDF 和 SDRF 文件对我们很重要。  
IDF 文件包含有关实验的顶级信息，
包括标题，说明，提交者联系详细信息和协议。  
SDRF 文件包含有关实验样本的基本信息，例如他们所属的实验组。

在我们继续进行实际的原始数据导入之前，
我们将简要介绍`r Biocpkg("Biobase")` 包中包含的 `ExpressionSet` 类。
它通常用于在 Bioconductor 中存储微阵列数据。

## Bioconductor ExpressionSets

基因组数据可以非常复杂，
通常由许多不同的组分组成，例如，
有关实验样品的信息，测量的基因组特征的注释
以及实验数据本身。
在 Bioconductor 中， 采用的方法是将这些组件存储
在一个单结构中以便于管理数据。

`r Biocpkg("Biobase")`  包含标准化数据结构以表示基因组数据。
`ExpressionSet` 类旨在将几个不同的信息源
（即包含在各种 MAGE-TAB 文件中）组合
成一个方便的结构。
可以操纵 ExpressionSet（例如，子集化，复制）
并且是许多 Bioconductor 函数的输入或输出。

ExpressionSet 中的数据包括：

* **assayData**: 来自微阵列实验的表达数据，其中每行是微阵列探针，每列是样品标识符。
其中每行是微阵列探针，每列是样品标识符。
* **metaData**
    + **phenoData**: 实验中样本的描述，每行是样本标识符，每列是描述元素; 储存的是 SDRF 文件的内容。
    + **featureData**: 有关芯片功能的元数据或者用于实验的技术，
    默认情况下使用与 assayData 相同的行和可自由分配的列。
    + 进一步注释特征，例如来自生物医学数据库（注释）的基因注释。
    例如来自生物医学数据库（注释）的基因注释。

* **experimentData**: 一种灵活的结构来描述实验。

ExpressionSet 类协调所有这些数据，因此不必
担心细节。 但是，应该记住，`phenoData` 的 rownames （行名）必须与 assay data 的列名匹配，
而 assayData 的行名必须与 `featureData` 的行名匹配。
这在图1中说明。 \@ref(fig:sumexp).


```{r sumexp, fig.cap = "Structure of Bioconductor’s ExpressionSet class.", echo=FALSE, fig.show="asis", fig.width = 7, fig.height = 4.5}
par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 150),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")

polygon(c(50,85,85,50),c(70,70,130,130),col="lightcoral",border=NA)
polygon(c(55, 56, 56, 55),c(70,70,130,130),col=rgb(1,0,0,.5),border=NA)
polygon(c(50,85,85,50),c(118,118,120,120),col=rgb(1,0,0,.5),border=NA)
text(67.5,100,"assay(s)", cex = 1)
text(67.5,90,"e.g. 'exprs'", cex = 1)

polygon(c(45,49,49,45),c(70,70,130,130),col="honeydew2",border=NA)
text(47,100, "microarray probes", srt=90, cex=1)

polygon(c(50,85,85,50),c(131,131,140,140),col="darkseagreen3",border=NA)
text(67.5,135.5,"sample IDs", cex = 1)


polygon(c(20,40,40,20),c(70,70,130,130),col=rgb(0,0,1,.5),border=NA)
polygon(c(20,40,40,20),c(118,118,120,120),col=rgb(0,0,1,.5),border=NA)
text(30,100,"featureData", cex = 1)

polygon(c(15,19,19,15),c(70,70,130,130),col="honeydew2",border=NA)
text(17,100, "microarray probes", srt=90, cex=1)

polygon(c(20,40,40,20),c(131,131,140,140),col="bisque3",border=NA)
text(30,135.5,"features", cex = 1)

polygon(c(50,65, 65, 50),c(55, 55, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
polygon(c(55, 56, 56, 55),c(55, 55, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
text(57.5, 30,"phenoData", cex = 1, srt=270)

polygon(c(50,65, 65, 50),c(56,56,65,65),col="darkseagreen3",border=NA)
text(57.5,60.5,"sample IDs", cex = 1)
```

您可以使用函数 ` pData ` 和 ` fData ` 分别从 
` ExpressionSet ` 中提取样本和要素注记。
函数 ` exprs ` 将表达式数据本身作为矩阵返回。

# 导入注释数据和微阵列表达数据为 "ExpressionSet"

我们使用原始数据文件夹中的 `read.delim` 函数导入
SDRF 文件，以获取样本注释。

样本名称在 SDRF 数据表的 Array.Data.File 列中给出，并将用作 SDRF 文件的 rownames 。

我们将 SDRF 表转换为 `r Biocpkg("Biobase")` 包中
的 `AnnotatedDataFrame` ，稍后我们将需要为我们的数据
创建一个 `ExpressionSet`[@Bioc].

```{r getSDRF}
sdrf_location <- file.path(raw_data_dir, "E-MTAB-2967.sdrf.txt")
SDRF <- read.delim(sdrf_location)

rownames(SDRF) <- SDRF$Array.Data.File
SDRF <- AnnotatedDataFrame(SDRF)
```


我们现在创建 Expression Set object 
`raw_data`,它包含陈列数据，pheno data (表型数据)
（来自 SDRF 文件） 以及所使用
的芯片注释包的信息。


Affymetrix 列阵的分析是从 CEL 文件开始。这些是使用 
Affymetrix 软件处理原始图像文件
并包含估计的探针强度值的结果。每个 CEL 文件还包含一些元数据，
例如芯片标识符。

我们使用 `r Biocpkg("oligo") ` 包[@oligo]中的 `read.celfiles`  
函数导入文件：

```{r importCelfiles, results="hide", eval=TRUE, dependson="getSDRF", warning = FALSE }
raw_data <- oligo::read.celfiles(filenames = file.path(raw_data_dir, 
                                                SDRF$Array.Data.File),
                                    verbose = FALSE, phenoData = SDRF)
stopifnot(validObject(raw_data))
```

这会自动创建一个 ExpressionSet,
用 CEL 文件中的数据填充部分 "array data"
并使用正确的芯片注释包，在本例中为 
`r Biocannopkg("pd.hugene.1.0.st.v1") ` (
芯片类型也存储在 .CEL 的文件)。

此外，我们将早先从 SDRF 文件创建的 `AnnotatedDataFrame`
 "`SDRF`" 指定为 `phenoData`. 因此，
我们必须确保按照与 SDRF 表对应的顺序导入 CEL 文件
- 为了强制执行此操作，我们使用 `SDRF`
表的 `Array.Data.File` 列作为 `filenames` 
(文件名) 参数。

最后，我们检查了创建的对象是否有效
(例如，不同表之间的样本名称是否匹配）。

我们现在首先看一下原始数据。

Biobase 包的 `pData` 函数直接访问 ExpressionSet `raw_data` 中的 phenoData。使用 `head()` 函数，我们可以查看
表的前六行。我们需要查看包含的列，
并仅保留与感兴趣的实验因子
相关的列。

```{r inspectPhenoData, eval=TRUE }
head(Biobase::pData(raw_data))
```


我们感兴趣的列如下：

  * 个人的标识符，即列名 "Source.Name", "Characteristics.individual."
  * 个体的疾病，即名为 "Factor.Value.disease."
  * 粘膜类型，即名为 "Factor.Value.phenotype."

我们现在再次选择相应的列： 

```{r reassignpData, eval=TRUE}
Biobase::pData(raw_data) <- Biobase::pData(raw_data)[, c("Source.Name",
                                     "Characteristics.individual.",
                                     "Factor.Value.disease.",
                                     "Factor.Value.phenotype.")]
```

# 原始数据的质量控制

初始数据导入后的第一步是数据的质量控制。 
在这里，我们检查异常值并尝试查看数据是否按预期聚类，
例如 由实验条件。 表达强度值在 
assayData 子对象 "exprs" 中，并且可以由 `exprs(raw_data)` 
函数访问。 每行代表微阵列探针，即 
芯片上的单个 DNA 位置，
而每列代表一个微阵列，
即每个患者的发炎和非发炎组织的样品。

```{r inspectAssayData, eval=TRUE}
Biobase::exprs(raw_data)[1:5, 1:5]
```


对于质量控制，我们采用 `Biobase::exprs(raw_data) `的 log2，
因为表达数据通常以 log 分析。

然后，我们执行主成分分析（PCA）并绘制它 \@ref(fig:qualityControlRawDataPCA))
图中的每个点代表一
个样本，颜色表示粘膜类型
(发炎与未发炎）和表示疾病的形状（ UC 或 CD ）。



```{r qualityControlRawDataPCA, fig.cap="PCA plot of the log–transformed raw expression data."}
exp_raw <- log2(Biobase::exprs(raw_data))
PCA_raw <- prcomp(t(exp_raw), scale. = FALSE)

percentVar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
                    Disease = pData(raw_data)$Factor.Value.disease.,
                    Phenotype = pData(raw_data)$Factor.Value.phenotype.,
                    Individual = pData(raw_data)$Characteristics.individual.)

ggplot(dataGG, aes(PC1, PC2)) +
      geom_point(aes(shape = Disease, colour = Phenotype)) +
  ggtitle("PCA plot of the log-transformed raw expression data") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(4,15)) + 
  scale_color_manual(values = c("darkorange2", "dodgerblue4"))
```

原始数据的 PCA 图 (Figure \@ref(fig:qualityControlRawDataPCA), 在对数强度标度上进行
) 显示 第一主成分 (first PC) 区分疾病。  
这意味着
疾病类型是基因表达差异的主要驱动因素。
这可能会妨碍我们的分析，因为我们想要分析发炎组织和非发炎组织之间的差异表达，
而不是人们患病的疾病的关系。

我们还通过箱形图图表示探针强度，
每个单独的微阵列是有一个箱。(Figure \@ref(fig:qualityControlRawDataBox)). 注意， 
`oligo::boxplot` 函数，即 oligo 包的 boxplot() 函数，
可以将表达式集作为参数。
它访问表达式数据并默认执行 log2 转换。 因此，我们可以在这里使用 `raw_data` 作为参数。

```{r qualityControlRawDataBox, fig.cap="Intensity boxplots of the log2–transformed raw data."}
oligo::boxplot(raw_data, target = "core", 
               main = "Boxplot of log2-intensitites for the raw data")
```

当查看箱形图 (Figure \@ref(fig:qualityControlRawDataBox)) 时，
我们看到各个阵列的强度分布完全不同，
这表明需要进行适当的归一化，
我们将在下面讨论。

到目前为止，我们只进行了非常基本的质量控制; 
`r Biocpkg("arrayQualityMetrics")` [@AQM] 中提供了
更精细的质量控制图。 该软件包可以生成一个 html 报告，
其中包含质量控制图以及对其目标的描述以及可能的异常值的识别。
我们在此不详细讨论此工具，
只是提供下面的代码，
它为我们的原始数据创建报告。

```{r arrayQualityMetricsRaw, eval = TRUE, warning=FALSE, message=FALSE}
arrayQualityMetrics(expressionset = raw_data,
    outdir = tempdir(),
    force = TRUE, do.logtransform = TRUE,
    intgroup = c("Factor.Value.disease.", "Factor.Value.phenotype."))
```

# 背景调整，校准，摘要和注释

## 背景调整

在初始导入和质量评估之后，
处理微阵列数据的下一步是背景调整。
这是必要的因为测量的探针强度的一部分
是由于非特异性杂交和光学检测系统中的噪声。
因此，需要调整观察到的强度
以给出特定杂交的准确测量。

## 跨阵列归一化（校准）

因为许多差异的来源并不明确，
所以要标准化跨阵列以便能够比较来自不同阵列杂交的测量结果。
这些包括逆转录，
标记或杂交反应的不同效率，
阵列的物理问题，
试剂批次效应
和实验室条件。 

## 概要

我们必须在归一化后进行汇总，
因为在Affymetrix平台上，
转录本由多个探针表示，即阵列上的多个位置。
对于每个基因，需要将所有探针的背景调整
和标准化强度总结为一个量，
让预计与 RNA 转录物的量成比例的量。

在汇总步骤之后，汇总数据可以用各种信息注释，
例如，基因符号和 ENSEMBL 基因标识符。
Bioconductor 为我们的平台提供了一个注释数据库，
即
`r Biocannopkg("hugene10sttranscriptcluster.db") `包。

您可以像这样查看其内容：

```{r annotationDataBaseContent, eval = TRUE}
head(ls("package:hugene10sttranscriptcluster.db"))
```

更多信息可从包装的参考手册中获得。
本质上该包提供从转录本簇标识
符到各种注释数据的映射。

## Affymetrix 微阵列的新旧 “探针组”

传统来说，Affymetrix 阵列（所谓的3'IVT 阵列）基于探针组：
某一固定探针组是探针组的一部分，
该探针组代表某种基因或转录物
但请注意，基因可由多个探针组表示）。

最近的“基因”和“外显子” Affymetrix 阵列是基于外显子的，
因此有两个级别的总结可以达到基因水平。探针组”总结导致外显子水平。基因/转录物水平由“转录物簇”给出。 因此，我们的芯片类型的适当注释包
名为 
`r Biocpkg("hugene10sttranscriptcluster.db") `.

通过仅从外显子阵列中获取“好”的探针，
“基因”阵列被创建为“外显子”阵列的负担得起的版本。 
最初在外显子阵列上，至少有四个探针是一个“外显子”的一部分。
通过稀释的“基因”阵列，许多探针组由三个或更少的探针组成。
这在图4 中可视化：\@ref(fig:DifferenceBetweenExonAndGeneTypeArrays)
单个探针组由单色标注; 
表示一个基因的探针组用色调表示：
例如，所有黄色探针属于一个外显子，
并且所有黄色，橙色和红色探针组属于一个基因： 

```{r DifferenceBetweenExonAndGeneTypeArrays, fig.width=7, fig.height=6, echo=FALSE, fig.cap="Visualization of the difference between \"Exon\" type array (left) and \"Gene\" type array (right)."}
library(grid)

par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 20),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")
dat <- data.frame(x = rep(seq(0, 2.9, 0.1), 30), 
                  y = rep(seq(0, 2.9, 0.1), each = 30))


col <- c("blue", "darkslategray1", "goldenrod1", "yellow", "royalblue1", "coral")
dat$colours<-sample(rep(col, 150))
dat$colours2 <- sample(c(rep("yellow", 2), rep("goldenrod1", 5), rep("coral",7), 
                  rep("blue", 5), rep ("darkslategray1",3), rep("royalblue1", 8), rep(gray(0:9/10), 87)))

# opening the graphic device and
# setting up a viewport with borders:
vp1 <- viewport(x = 0.1, y = 0.1, w = 0.12, h = 0.12, 
                just = c("left", "bottom"), name = "vp1")


# plotting rectangles using x/y positions
grid.rect(x=dat$x,y=dat$y, height=0.1, width=0.1, hjust=0,vjust=0,vp=vp1,
          gp=gpar(col=1, fill=as.character(dat$colours)))

##########################

vp2 <- viewport(x = 0.5, y = 0.1, w = 0.12, h = 0.12,
                just = c("left", "bottom"), name = "vp1")


# plotting rectangles using x/y positions
grid.rect(x=dat$x,y=dat$y, height=0.1, width=0.1, hjust=0,vjust=0,vp=vp2,
          gp=gpar(col=1, fill=as.character(dat$colours2)))
```


在左侧，我们看到每个外显子/探针组（即每种颜色）有大量探针：
因此，探针组/外显子水平上的摘要是合理的。
然而，在基因型阵列中，
每个探针组仅包括一小部分原始探针。
因此，不建议对 “基因” 阵列使用探针组/外显子级别进行汇总，
但仍然可以使用 `r Biocannopkg("hugene10stprobeset.db") ` 
注释包。

注意，此外，“基因”和“外显子”型芯片上
也不再存在指定的匹配/错配探针。 
错配探针最初用作背景校正的基础水平，
但由于更精细的背景校正技术
不需要不匹配探针而没有普及。

## 一步预处理寡核苷酸

`r Biocpkg("oligo") ` 包允许我们在一个步骤里使用用于背景校正，
归一化，和汇总。
这个包使用反卷积方法来背景校正，分位数归一化和
RMA (robust multichip average) 算法来汇总。

整个系列步骤通常称为 RMA 算法，
但严格来说 RMA 仅仅是一种汇总的方法
[@Irizarry_2003; @Bolstad_2003; @Irizarry_2003a].

# 相对日志表达式数据质量分析

在校准和评估数据之前，我们要执行另一个质量控制程序，
即相对对数表达式（RLE），
如 Gandolfo et al [@Gandolfo_2018]。 
我们首先执行没有事先规范化 RMA：

```{r RMAcalibrationForRLE, eval=TRUE}
palmieri_eset <- oligo::rma(raw_data, target = "core", normalize = FALSE)
```

在 RLE 分析之后，或当执行 “完整” RMA（包括归一化）时， 
将提供关于 RMA 算法的进一步细节。

## 计算 RLE

通过计算所有阵列上每个转录物的 log2 
强度中值来进行 RLE。

我们通过计算 `exprs(palmieri_eset)`的行中值来做到这一点，
因为转录本由每行表示，
单个微阵列由每列表示。

注意，我们不必手动应用 log2，
因为默认情况下 RMA 函数的输出数据为 log2 比例。

然后我们通过  `sweep`函数从每个转录物强度中
减去该转录物中值强度。

## 绘制 RLE 图

我们最终将数据重新整形为一种格式，我们可以使用这种格式 
为每个数组创建一个箱形图 (boxplot) ，如前所述：


```{r boxplotDataForRLETidy, fig.cap="Boxplot for the RLE values", warning=FALSE}
row_medians_assayData <- 
  Biobase::rowMedians(as.matrix(Biobase::exprs(palmieri_eset)))

RLE_data <- sweep(Biobase::exprs(palmieri_eset), 1, row_medians_assayData)

RLE_data <- as.data.frame(RLE_data)
RLE_data_gathered <- 
  tidyr::gather(RLE_data, patient_array, log2_expression_deviation)

ggplot2::ggplot(RLE_data_gathered, aes(patient_array,
                                       log2_expression_deviation)) + 
  geom_boxplot(outlier.shape = NA) + 
  ylim(c(-2, 2)) + 
  theme(axis.text.x = element_text(colour = "aquamarine4", 
                                  angle = 60, size = 6.5, hjust = 1 ,
                                  face = "bold"))
```

注意，现在 y 轴显示的是针对每个微阵列表达强度
与跨阵列的相应单个转录物
的表达中值的偏差。

因此，具有较大延伸的盒子表示在许多转录物中
与中值的异常高偏差，
表明这些阵列在某些方面与大多数其他阵列不同。

与大多数其他阵列相比，在 y 方向上移位的框表示
大多数转录物的系统性更高或更低的表达。
这可能是由质量问题或批量效应引起的。 

因此，如果给定盒子的形状和中位数与体积相差太大，
则应检查并可能将其移除。

通过检查图 5 中的箱线图 \@ref(fig:boxplotDataForRLETidy), 
可以将五个阵列视为异常值:
2826_I，2826_II，3262_II，3302_II 和 3332_II 被负 y 移位。 

我们将记住这些样本，
以便稍后在工作流程中进行热图聚类分析。 
通过热图分析确认为异常值的阵列可以在后续分析前移除。


# RMA 校准数据

现在，我们可以将完整的 RMA 算法应用于我们的数据，
以便进行背景校正，规范化和总结：

```{r RMAcalibrationWITHnormalization, eval=TRUE}
palmieri_eset_norm <- oligo::rma(raw_data, target = "core")
```

参数 `target` 用来定义摘要的程度，
默认选项是“核心”，
使用含有“安全”注释基因的转录物簇。对于外显子级别的汇总（不建议用于基因阵列)，
可以使用 "probeset" 作为 target 选项。
虽然存在其他背景校正和归一化方法，
但 RMA 通常是一个很好的默认选择。
RMA 跨阵列共享信息，
并使用通用的分位数归一化方法，
使阵列强度分布匹配。但是，最好只在
删除异常值后才应用它。
RMA 使用的分位数归一化算法
通过将数值替换为数组中相同排名（单个芯片内）值的平均值来工作。
更详细的描述可以在
维基百科页面上找到 [Wikipedia page](https://en.wikipedia.org/wiki/Quantile_normalization).

分位数归一化的替代方案是 `r Biocpkg("vsn") ` 算法，
其通过在对数变换之前对阵列内的强度值
进行鲁棒地移位和缩放来执行背景校正和归一化。
这跟分位数归一化 [@vsn] 比不那么“严重”。

## 关于归一化（校准）和背景校正的一些数学背景知识

微阵列上单个探针的强度 \(Y\) 值的通用模型
由下式给出：

\[
    Y = B + \alpha \cdot S
\]
    
其中 B 是由于背景噪音引起的随机数量，
通常由光学效应和非特异性结合组成， \(\alpha\) 是增益因子，
 \(S\) 是测量的特异性结合量。 信号 \(S\) 
也被认为是随机变量， 
并且考虑了测量误差和探测效应。
通常假设测量误差是乘法的，因此我们可以写：

\[
    \log(S) = \theta + \varphi + \varepsilon
\]
    
这里 \(\theta\) 表示真实丰度的对数，
\(\varphi\) 是探针特异性效应 $\varepsilon$ 表示
非特异性误差。
这是 RMA 使用的微阵列数据的加法 - 乘法 - 误差模型
以及 `r Biocpkg("vsn") ` 算法 [@vsn]. 算法的不同之处
在于去除 \(B\) 并获得 \(\theta\) 的估计。


## 校准数据的质量评估

我们现在使用校准数据生成聚类热图
和另一个 PCA 图。

**PCA 分析**

首先，我们对校准数据进行 PCA 分析，
类似于原始数据：

```{r PCAMetricsCalibrated, fig.cap = "PCA plot of the calibrated, summarized data.", eval = TRUE }
exp_palmieri <- Biobase::exprs(palmieri_eset_norm)
PCA <- prcomp(t(exp_palmieri), scale = FALSE)

percentVar <- round(100*PCA$sdev^2/sum(PCA$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA$x[,1], PC2 = PCA$x[,2],
                    Disease = 
                     Biobase::pData(palmieri_eset_norm)$Factor.Value.disease.,
                    Phenotype = 
                     Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.)


ggplot(dataGG, aes(PC1, PC2)) +
      geom_point(aes(shape = Disease, colour = Phenotype)) +
  ggtitle("PCA plot of the calibrated, summarized data") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(4,15)) + 
  scale_color_manual(values = c("darkorange2", "dodgerblue4"))
```

与 RMA 之前的第一次 PCA 分析相比 (Figure \@ref(fig:qualityControlRawDataPCA)), 我们看到现在第一个主要成分 PC 
在组织类型之间分离 (Figure \@ref(fig:PCAMetricsCalibrated))。
这表明现在组织类型之间的差异表达
是变异的主要来源。 注意，第二 PC
分离疾病。

**热图聚类分析**

我们想要绘制具有样本到样本距离的热图，
样本名称为行名。 此外，我们希望看到样本分别表现为表型
（发炎和非发炎组织）和疾病（UC和CD）的程度。 
我们使用行注释：这意味着这些功能获得颜色代码并将显示在每行的左侧。

```{r rownamesForHeatmap, fig.height = 8.5, fig.width = 7, eval = TRUE, echo=TRUE}
phenotype_names <- ifelse(str_detect(pData
                                    (palmieri_eset_norm)$Factor.Value.phenotype.,
                             "non"), "non_infl.", "infl.")

disease_names <- ifelse(str_detect(pData
                                    (palmieri_eset_norm)$Factor.Value.disease.,
                             "Crohn"), "CD", "UC")

annotation_for_heatmap <- 
  data.frame(Phenotype = phenotype_names,  Disease = disease_names)

row.names(annotation_for_heatmap) <- row.names(pData(palmieri_eset_norm))

```

为了映射样本到样本的距离， 
我们首先使用 `dist` 函数计算距离。我们需要转换表达式值，
因为函数默认计算行之间的距离（例如我们的基因)。
默认距离是欧几里德距离。然而，这可以改变，
我们在这里选择曼哈顿距离 
（它使用沿矩形路径的绝对距离而不是直接路径的平方距离），
因为它更稳健。
我们将距离矩阵的对角线设置为 ` NA ` ，
以增加颜色编码的对比度。 
那些对角线条目不包含信息，
因为样本到自身的距离总是等于零。


```{r HeatmapWithAnnotation, fig.height = 8.5, fig.width = 7, fig.cap="Heatmap of the sample-to-sample distances"}
dists <- as.matrix(dist(t(exp_palmieri), method = "manhattan"))

rownames(dists) <- row.names(pData(palmieri_eset_norm))
hmcol <- rev(colorRampPalette(RColorBrewer::brewer.pal(9, "YlOrRd"))(255))
colnames(dists) <- NULL
diag(dists) <- NA

ann_colors <- list(
  Phenotype = c(non_infl. = "chartreuse4", infl. = "burlywood3"),
  Disease = c(CD = "blue4", UC = "cadetblue2")
                   )
pheatmap(dists, col = (hmcol), 
         annotation_row = annotation_for_heatmap,
         annotation_colors = ann_colors,
         legend = TRUE, 
         treeheight_row = 0,
         legend_breaks = c(min(dists, na.rm = TRUE), 
                         max(dists, na.rm = TRUE)), 
         legend_labels = (c("small distance", "large distance")),
         main = "Clustering heatmap for the calibrated samples")
```
在热图 (Figure \@ref(fig:HeatmapWithAnnotation)) 中，
我们还发现样品不会被组织强烈聚集，
证实了 PCA 图 (Figure \@ref(fig:PCAMetricsCalibrated)) 的印象，
即组织之间的分离并不完美。热图中的黄色条纹
可能对应于可能被删除的异常值：这里可以标记的异常值
是 2826_II, 3262_II, 3271_I, 2978_II 和 3332_II。
因为发现 2826_II, 3262_II 和 3332_II 在 RLE 和热图分析中都是异常值，
因此可能被删除; 但是，
为了尽可能接近原始论文，
我们继续提供完整的样本集。
注意  `r Biocpkg("arrayQualityMetrics")`包提供了更精细的标识
来识别和删除异常值。


# 根据强度过滤

我们现在过滤掉低表达的基因。微阵列数据通常
在背景强度范围内显示大量探针。 这些探针
在数组之间也没有太大变化。因此，
它们结合了低方差和低强度。因此，它们最终可能被检测为差异表达，
尽管它们几乎不高于 “detection” 限制并且
通常不是非常有用的信息。 

我们将在这里执行基于“软”强度的过滤，因为这是
 `r Biocpkg("limma")` [@limma; @Smyth_2004] 用户指南推荐的
(我们将在下面用于差异表达式分析的包
差异表达式分析的包)。 

但请注意，基于方差的过滤器在实践中可能会排除
一组类似的探测。  
对于基于强度的过滤，我们从表达式数据计算行式中位数， 
因为它们代表转录中位数，并将它们分配给
`palmieri_medians`。从这里我们创建一个直方图：

```{r IntensityBasedManualFiltering, fig.cap="Histogram of the median intensities per gene"}
palmieri_medians <- rowMedians(Biobase::exprs(palmieri_eset_norm))

hist_res <- hist(palmieri_medians, 100, col = "cornsilk1", freq = FALSE, 
            main = "Histogram of the median intensities", 
            border = "antiquewhite4",
            xlab = "Median intensities")
```

在基因中位数的直方图中 (Figure 
\@ref(fig:IntensityBasedManualFiltering))，
我们可以清楚地看到左侧低中值的富集。
这些代表了我们想要过滤的基因。 为了推断数据的截止，
我们检查直方图：我们在直方图峰的左侧可视地设置截止线 `man_threshold` 
以便不排除太多基因。  在我们的示例中，
我们选择阈值 4 。我们绘制与之前相同的直方图，
并使用 `abline()` 函数添加阈值线：

```{r setManualThreshold, fig.cap="Histogram of the median intensities per gene with manual intensity filtering threshold (red line)."}
man_threshold <- 4

hist_res <- hist(palmieri_medians, 100, col = "cornsilk", freq = FALSE, 
            main = "Histogram of the median intensities",
            border = "antiquewhite4",
            xlab = "Median intensities")

abline(v = man_threshold, col = "coral4", lwd = 2)
```

排除在至少与最小实验组一样多的阵列中
不具有大于阈值的强度的转录物。 

为了做到这一点，我们首先必须得到一个列表，
其中包含实验组中的样本数（=数组）(`no_of_samples`):

```{r expGroups, dependson="PCAMetricsCalibrated"}
no_of_samples <- 
  table(paste0(pData(palmieri_eset_norm)$Factor.Value.disease., "_", 
                  pData(palmieri_eset_norm)$Factor.Value.phenotype.))
no_of_samples 
```


我们现在过滤掉所有
不具有大于阈值强度的转录本，
至少与我们定义为 (`r min(no_of_samples)`) 
 `samples_cutoff` 一样多。

然后将函数 `idx_man_threshold` 应用于每一行，
即应用于所有数组的每个转录本。
它评估中值强度超过阈值的数组的数量
(`sum(x > man_threshold)`) 是否大于 `samples_cutoff` 并且
对于每一行（即每个转录本）返回 TRUE 或 FALSE。

然后，我们创建一个 `idx_man_threshold` 表来汇总结果，
并概述过滤掉多少基因。 
在最后一步中，我们将表达式集合为 `palmieri_manfiltered`，
并保留 `idx_man_threshold`的 TRUE 元素。

```{r filteringOfLowIntensity_transcripts}
samples_cutoff <- min(no_of_samples)

idx_man_threshold <- apply(Biobase::exprs(palmieri_eset_norm), 1,
                           function(x){
                          sum(x > man_threshold) >= samples_cutoff})
                          table(idx_man_threshold)

palmieri_manfiltered <- subset(palmieri_eset_norm, idx_man_threshold)
```


# 抄本集群的注释

在继续使用微阵列和差异表达的线性模型之前，
我们首先将“特征数据”，
即注释信息添加到存储在 ExpressionSet 的 featureData 
中的转录集群标识符：

```{r annotateData, eval=TRUE, dependson="intensityBasedFiltering", message = FALSE}
anno_palmieri <- AnnotationDbi::select(hugene10sttranscriptcluster.db,
                                  keys = (featureNames(palmieri_manfiltered)),
                                  columns = c("SYMBOL", "GENENAME"),
                                  keytype = "PROBEID")

anno_palmieri <- subset(anno_palmieri, !is.na(SYMBOL))
```

我们使用 `r Biocpkg("AnnotationDbi") ` 中的 `select` 来查询
转录本簇的基因符号和相关的简短描述。
对于每个簇，我们添加了基因符号 (`SYMBOL`) 和簇代表的基因
的简短描述 (`GENENAME`)。

在第二步中，我们过滤掉了未映射到基因的探针，
即没有分配基因符号的探针。

## 删除多个映射

许多转录物簇标识符将映射到多个基因符号，
即它们不能被明确地分配。

我们在下面的代码中计算一个汇总表，看看有多少：


```{r multipleMappings, dependson="annotateData"}
anno_grouped <- group_by(anno_palmieri, PROBEID)
anno_summarized <- 
  dplyr::summarize(anno_grouped, no_of_matches = n_distinct(SYMBOL))

head(anno_summarized)

anno_filtered <- filter(anno_summarized, no_of_matches > 1)

head(anno_filtered)

probe_stats <- anno_filtered 

nrow(probe_stats)
```

首先，我们用他们的 PROBEID 对 `anno_palmieri`  进行了分组; 
这样，后续操作不会针对每一行进行，
而是针对每个组，即每个 PROBEID 。
然后，我们对这些组进行了总结，
并在  `no_of_matches` 列中指出了分配给转录物簇的不同基因的数量。
最后，我们使用多个匹配过滤了 PROBEIDs ，
即 `no_of_matches > 1`。

使用 `dim(probe_stats)`， 我们可以看到
有多少探针被映射到多个基因。

我们有接近 2000 个转录物簇，映射到多个基因符号。
很难确定哪个映射是“正确的”。
因此，我们排除这些转录本群集。 

我们想要删除那些与 `probe_stats` 中的 probe IDs 匹配的 ID。
因为它们是具有多个映射的探测器。我们将这些 ID
分配给变量 `ids_to_exclude`。然后，我们生成 `palmieri_final`, 
一个没有 `ids_to_exclude`的表达式集。

```{r excludeMultipleMappingsFromAssayData, dependson="multipleMappings"}
ids_to_exlude <- (featureNames(palmieri_manfiltered) %in% probe_stats$PROBEID)

table(ids_to_exlude)

palmieri_final <- subset(palmieri_manfiltered, !ids_to_exlude)

validObject(palmieri_final)
```

由于我们刚刚从化验数据中排除了 probe IDs，
我们现在还必须将它们从特征数据 `anno_palmieri`中排除：

```{r recallAnnoPalmieri}
head(anno_palmieri)
```

回想一下， `fData` 使我们能够访问表达式集的特征数据。
到目前为止，没有任何特征数据存储在 `fData(palmieri_final)` 中。
默认情况下，只有行名称是化验数据的行名称，它们是转录本的
PROBEIDs。

因此，我们在 `fData(palmieri_final)`中生成一列 PROBEID，
并为其分配 `fData(palmieri_final)` 的行名：

```{r excludeMultipleMappingsFromFeatureData}
fData(palmieri_final)$PROBEID <- rownames(fData(palmieri_final))
```

然后，我们左手连接数据 `fData(palmieri_final)` 和 `anno_palmieri`，
它已经包含 columns "SYMBOL" 和 "GENENAME" 列。
left-join 保留第一个参数的行和列， 
并添加第二个参数的相应列条目：

```{r excludeMultipleMappingsFromFeatureData2}
fData(palmieri_final) <- left_join(fData(palmieri_final), anno_palmieri)


# restore rownames after left_join
rownames(fData(palmieri_final)) <- fData(palmieri_final)$PROBEID 
    
validObject(palmieri_final)
```

通过与 `anno_palmieri` 的左连接，我们因此只为 `anno_palmieri` 中的 
"SYMBOL" 和 "GENENAME" 列添加了 `fData(palmieri_final)` 中的 
PROBEID ，从而获得过滤探测的特征数据。


## 构建自定义注释

或者，可以将阵列的探针重新映射到当前注释。
在 @Arloth_2015 中给出了为 Illumina 阵列执行此操作的工作流程。 
基本上，
将各个探针序列重新比对由包含所有注释的
转录物外显子的计算机“外体组”。

在任何情况下，`r Biocpkg("pdInfoBuilder") ` 包都可用于构建用于
`r Biocpkg("oligo") ` 的 customannotation 包。
为此，需要 PGF / CLF 文件（在 Affymetrix 网站上称为“库文件”）
以及探针集注释。
探针组通常代表基因组的小片段
（例如单个外显子），
然后使用多个探针组形成转录物簇。

CLF 文件包含有关阵列上各个探针位置的信息。
然后，PGF 文件包含各个探测序列，
并显示它们所属的探针组。最后，probeset 注释 .csv 
然后包含有关在哪个 transcript 集群中
使用哪些 probeset 的信息。
通常，在一个转录物簇中使用多个探针组，
并且一些探针组包含在多个转录物簇中。


# 线性模型

为了分析哪些基因在发炎组织和非发炎组织之间差异表达， 
我们必须将线性模型拟合到我们的表达数据中。
线性模型是分析实验数据的“主力”。 
它们可用于分析几乎任意复杂的设计，
但是它们也需要一段时间来学习和理解，
并且详尽的描述超出了本工作流程的范围。

Mike Love's 和 Rafael Irizzary's ["Biomedical Data Science"](http://genomicsclass.github.io/book/) [@Irizarry_2015] 是一个非常好的资源，尤其是关于[interactions and contrasts](http://genomicsclass.github.io/book/pages/interactions_and_contrasts.html).的部分。
学习一些线性代数以更好地理解这里的概念也可能有所帮助。
The Khan Academy 提供有用（和免费）的在线课程。 [online courses](https://www.khanacademy.org/math/linear-algebra).

## 微阵列的线性模型

我们现在将线性模型应用于微阵列。 具体来说，我们讨论如何使用
`r Biocpkg("limma") ` 包进行差异表达式分析。
该包用于分析复杂实验， 
包括同时在许多实验组之间进行比较， 
同时保持相当容易用于简单实验。 
主要思想是将线性模型拟合到每个基因的表达数据。
经验贝叶斯和其他方法被用于借助基因信息来进行剩余方差估计， 
从而导致“适度” \(t\)-statistics, 并稳定
仅使用少量阵列的实验分析 [@Smyth_2004]. 
从概念上讲，
每个基因的最终方差是先验方差和每个基因方差的混合。

典型的实验设计在 `r Biocpkg("limma") `
"用户指南"的第9章中讨论，可以在`r Biocpkg("limma") `
登陆页面上找到。

在下文中，我们为线性模型使用适当的设计和对比矩阵，
并分别为每个基因拟合线性模型。

## 数据的线性模型

对于随后的数据线性建模， 
我们分别为疾病类型引入缩写“UC”和“CD”，
并为表型引入 “non_infl” 和 “infl”：

```{r introductionOfAbbreviations}
individual <- 
  as.character(Biobase::pData(palmieri_final)$Characteristics.individual.)

tissue <- str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.phenotype.,
                  " ", "_")

tissue <- ifelse(tissue == "non-inflamed_colonic_mucosa",
                 "nI", "I")

disease <- 
  str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.disease.,
                  " ", "_")
disease <- 
  ifelse(str_detect(Biobase::pData(palmieri_final)$Factor.Value.disease., 
                    "Crohn"), "CD", "UC")
```

原始论文对发炎和邻近的非发炎的结肠粘膜区域之间
发生的转录变化感兴趣。
这在两种炎症性肠病中都有研究。

为了构建我们的线性模型，
我们必须考虑我们想要考虑哪些实验变量。 
由于我们希望找到非发炎和发炎组织之间的
差异表达，
原则上，
这些是我们必须考虑的唯一两个变量。

但是，由于每个患者有两个阵列，
我们有一个“配对样本”设计 (参见 第 9.4 节 of the `r Biocpkg("limma")` 
用户指南). 这意味着样本可能会受到来自的人的偏见。 
每当预期实验装置中的特征对结果
具有系统性影响时， 
应引入这些特征的阻塞因子。

因此，我们需要的第一个因素是个体的阻滞因子，
它将吸收它们之间表达的差异。
因此，我们阻止患者，
这意味着患者 ID 成为线性模型的变量。

然后我们创建了一些因子，
这些因子可以为我们提供组织类型的分组（非发炎和发炎）。

最后，我们创建两个设计矩阵，
分别针对两种疾病中的每一种， 
因为我们将分别对它们进行分析，
以便密切关注原始论文的分析策略
也可以将一个联合模型拟合到完整的数据集;
但是，两种疾病可能表现出非常不同的特征，因此联合适合可能不合适）。

```{r createDesign, eval=TRUE, dependson="excludeMultipleMappings" }
i_CD <- individual[disease == "CD"]
design_palmieri_CD <- model.matrix(~ 0 + tissue[disease == "CD"] + i_CD)
colnames(design_palmieri_CD)[1:2] <- c("I", "nI")
rownames(design_palmieri_CD) <- i_CD 

i_UC <- individual[disease == "UC"]
design_palmieri_UC <- model.matrix(~ 0 + tissue[disease == "UC"] + i_UC )
colnames(design_palmieri_UC)[1:2] <- c("I", "nI")
rownames(design_palmieri_UC) <- i_UC 
```

我们可以检查设计矩阵：

```{r inspectDesignMatrix, eval = TRUE, dependson="createDesign"}
head(design_palmieri_CD[, 1:6])

head(design_palmieri_UC[, 1:6])
```

在设计矩阵中，行表示患者阵列，
列是我们在线性模型中包含的变量。
变量对应于我们的阻塞因素: 对于非发炎和发炎的组织分别有两个，
每个患者一个。例如， "`i_UC2424`" 是患者 2424 的阻断变量;
 "`i_UC2424`" 是患者 2424 的阻断变量;
UC 代表患者患的疾病。
例如，设计矩阵 `design_palmieri_CD` 的前两行对应于单个
的两个数组。

设计矩阵条目为 0 或 1
因此告诉我们哪个变量对于哪个样本是“活动的”：

它可以看作是一个开关， 
用于将每个行中的单个变量“打开”（在相应位置处为 1）或“关闭”（在相应位置处为 0 ），
即每个患者阵列。如果我们仔细查看单行，
我们会看到每个样本都分配了两个 “1”： 
一个到一个变量 “nI” 或 “I” 对应于阵列来自的组织，
一个对应于相应的患者特异性阻断变量。

注意，在线性模型中，个体 164 用作所有其他个体的基线，
因此不包括在样本变量中。

请注意，不是阻止个人，也可以使用 `r Biocpkg("limma")` 包中的
`duplicateCorrelation()` 函数的
“混合模型”方法。 
它比这里提出的“固定患者效应模型”具有优势，
适用于更复杂的实验设计，
我们希望在患者内部和患者之间进行比较
（例如，比较两种疾病;“分裂情节设计”））。

有关它的更多信息可以在 [limma User's Guide](https://www.bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf) (section 17.3.6). 
 然而，以上说明更直观，因此在此使用。

在继续找到这两种疾病的所有差异表达基因之前， 
我们首先要看看这对于一种基因原理是如何起作用的。
我们将拟合一个基因的线性模型并进行t-test，
以查看该基因是否差异表达。

## 基于单个基因的差异表达分析

对于线性模型拟合和随后通过 t-test 进行差异表达的测试，
我们将使用 PROBEID 8164535 挑选基因。
它具有基因符号 *CRAT*  并将在以下代码中命名。

**插图：*CRAT* 基因拟合线性模型**

在拟合线性模型之前，
我们分别研究了该基因在非发炎和发炎组织中
的表达强度：


```{r visualizeExpressionChanges, fig.cap="Visualization of expression changes"}
tissue_CD <- tissue[disease == "CD"]
crat_expr <- Biobase::exprs(palmieri_final)["8164535", disease == "CD"]
crat_data <- as.data.frame(crat_expr)
colnames(crat_data)[1] <- "org_value"
crat_data <- mutate(crat_data, individual = i_CD, tissue_CD)

crat_data$tissue_CD <- factor(crat_data$tissue_CD, levels = c("nI", "I"))

ggplot(data = crat_data, aes(x = tissue_CD, y = org_value, 
                             group = individual, color = individual)) +
      geom_line() +
      ggtitle("Expression changes for the CRAT gene")
```

总体而言，我们看到这种基因在炎症组织中的表达较少
(Figure \@ref(fig:visualizeExpressionChanges))。我们还发现
患者之间的绝对表达强度差别很大。 
然而，我们已经
通过引入基于个体的阻断因子来解决这个问题，
这允许我们比较每个个体内的组织，
如单线所示。

如果我们没有阻止个体，
线性模型将可互换地对待它们，
并且图形描述将仅包括单行。 
由于个体具有非常不同的基线表达水平，
这将导致估计的倍数变化的非常高的方差。

我们现在通过拟合线性模型来计算变量系数。
我们得到一个向量 `crat_coef` ，每个变量有一个条目。

```{r obtainFitCRAT}
crat_coef <- lmFit(palmieri_final[,disease == "CD"],
                design = design_palmieri_CD)$coefficients["8164535",]

crat_coef
```


为了现在获得模型拟合的表达式值，
我们将设计矩阵乘以系数 `crat_coef`的向量：

```{r 2obtainFitCRAT}
crat_fitted <- design_palmieri_CD %*% crat_coef
rownames(crat_fitted) <- names(crat_expr)
colnames(crat_fitted) <- "fitted_value"

crat_fitted
```

回想一下，对于设计矩阵中的每一行（即每个患者样本），
仅考虑设计矩阵中具有1的变量
来计算拟合表达值。

这意味着作为乘法的输出， 
我们得到一个矢量 `crat_fitted`，
其条目分别是每个样本的相关变量系数的总和。

例如，患者样本 `2114_I.CEL` 的拟合值是
`r crat_coef["nI"] + crat_coef["i_CD2114"]`: 它是各个激活变量系数 "nI" (`r crat_coef["nI"]`) 
和 "i_CD2114" (`r crat_coef["i_CD2114"]`) 的总和。


让我们在拟合后
再次可视化非发炎和发炎组织之间的差异：

```{r 3obtainFitCRAT, fig.cap="Expression changes for the CRAT gene"}
crat_data$fitted_value <- crat_fitted

ggplot(data = crat_data, aes(x = tissue_CD, y = fitted_value, 
                             group = individual, color = individual)) +
      geom_line() +
      ggtitle("Fitted expression changes for the CRAT gene")
```


注意，一名患者的发炎和非发炎样本之间拟合表达值的差异对于所有患者是相同的，
并且由
`I` (`r crat_coef["I"]`) 和 `nI` (`r crat_coef["nI"]`)
的变量系数之间的差异确定
即  `r crat_coef["I"] - crat_coef["nI"]` 
(Figure \@ref(fig:3obtainFitCRAT)). 

情况就是这样，
因为来自单个患者的两个样本的设计矩阵激活相同的阻塞变量，
导致仅在患者内进行比较。
这些阻断变量使拟合的组织特异性表达值朝向个体患者的表达水平进行校正。
因此，
最终估计值就像所有个体内部差异的平均值。

非发炎组织和发炎组织之间的 “差异”
`r crat_coef["I"] -  crat_coef["nI"]` 实际上是 log2 倍变化， 
因为我们的表达数据是 log2 标度。因此，`r crat_coef["I"] - crat_coef["nI"]`
是 CRAT 基因的 log2 倍变化。

**CRAT 基因的差异表达分析**

为了测试基因是否差异表达， 
进行具有零假设的 \(t\)-test， 
即非发炎组织和发炎组织之间的表达没有差异。
我们的阻塞设计在概念上类似于配对t检验，
其统计数据由下式给出：


\[
 t = \frac{\bar{d} }{s/\sqrt{n}}
\]

其中, \(\bar{d}\) 是个体之间表达值
的平均差异。
paired t-test 从配对差异计算方差  \(s^2\)。
这低于标准 t-test 的方差，
因此只要同一个体的表达值相关， 
配对t检验就具有更高的功效（参见例如维基百科上的文章）。 ([see e.g. the article on Wikipedia](https://en.wikipedia.org/wiki/Paired_difference_test)).

因此，我们通过阻止个体来减少方差， 
从而提高了普通 \(t\)-test 的能力。

我们现在对线性模型进行 \(t\)-test，
以确定非发炎组织和发炎组织之间的差异 
是否与 0 显着不同: 

```{r tTest}
crat_noninflamed <- na.exclude(crat_data$org_value[tissue == "nI"])
crat_inflamed <- na.exclude(crat_data$org_value[tissue == "I"])
res_t <- t.test(crat_noninflamed ,crat_inflamed , paired = TRUE)
res_t
```

我们得到接近 `r round(res_t[["p.value"]], 4) ` 的低 p-value 值，
因此可以得出结论 *CRAT* 基因
在非发炎和发炎组织之间差异表达。

注意，在分析所有基因的差异表达时 p-value p值与下面的p值不完全相同。
这是由于由 `r Biocpkg("limma")`
执行的方差调节。

## 对比和假设测试

我们现在适合所有基因的线性模型，
并定义适当的对比来检验感兴趣的假设。

我们想比较发炎的和非发炎的组织。
因此，我们创建一个仅由一个对比度 "I-nI" 组成的对比矩阵: 
`r Biocpkg("limma")` 的函数
`makeContrasts` 根据感兴趣的
对比度的符号
描述创建该矩阵。

我们现在将线性模型拟合到我们的数据中并对其应用对比度 `contrasts.fit()` 函数，
以便找到在非发炎组织和发炎组织之间具有显着差异表达的基因：



```{r createContrastMatrixAndFitModel, eval=TRUE, dependson="createDesign" }
contrast_matrix_CD <- makeContrasts(I-nI, levels = design_palmieri_CD)

palmieri_fit_CD <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "CD"],
                                design = design_palmieri_CD),
                                contrast_matrix_CD))

contrast_matrix_UC <- makeContrasts(I-nI, levels = design_palmieri_UC)

palmieri_fit_UC <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "UC"],
                                design = design_palmieri_UC),
                                contrast_matrix_UC))
```

我们通过 `eBayes()` 函数将
经验贝叶斯方差调节方法应用于模型，
该函数计算调节的t统计量。
在微阵列分析中，阵列的数量通常非常小，
因此难以估计方差。
使用每基因方差和先验方差的组合，
我们可以改进方差估计，
因此术语“适度”，
“经验贝叶斯”意味着先验是根据数据估计的。

`eBayes()` 步骤的结果是
个体差异朝着先前值收缩。

## 提取结果

最后，我们提取差异表达基因的数量。
可以使用 `topTable`  函数提取结果。
我们提取克罗恩病和溃疡性结肠炎的结果， 
结果按其绝对t统计量排序。
作为诊断检查， 我们还绘制了 p 值直方图：
我们期望对应于真零假设的 p 值的均匀分布，
而接近零的峰显示对应于差异表达的低 p 值
的富集（DE）基因。
 
请注意，如果数据集的 p 值分布与下面的直方图中的 p 值分布非常不同，
则可能会导致后续分析中的质量损失。
p 值分布不同的原因可能是
批量效应或设计矩阵中缺乏对其他阻塞因素的考虑。 
因此，如果 p 值不符合预期，请尝试包括可能的阻塞因子和批次，
然后重新运行分析。
如果这没有帮助，
用于多次测试的经验贝叶斯/零估计方法是有用的。

了解这些方法的一个很好的起点是关于
Korbininan Strimmer [@Strimmer_2008] 的错误发现率估计和
Efron's  的大规模推理书 [@Efron_2010], 
以及关于“如何”解释 p值直方图的博客文章 by David 
Robinson [@Robinson_2014]。

```{r extractResultsCD, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for Crohn’s disease."}
table_CD <- topTable(palmieri_fit_CD, number = Inf)
head(table_CD)

hist(table_CD$P.Value, col = brewer.pal(3, name = "Set2")[1],
     main = "inflamed vs non-inflamed - Crohn's disease", xlab = "p-values")

```

```{r extractResultsUC, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for ulcerative colitis."}

table_UC <- topTable(palmieri_fit_UC, number = Inf)
head(table_UC)

hist(table_UC$P.Value, col = brewer.pal(3, name = "Set2")[2],
     main = "inflamed vs non-inflamed - Ulcerative colitis", xlab = "p-values")

```

## 多次测试 FDR，并与原始论文的结果进行比较

在原始论文中，p 值为 0.001 用作显着性截止值。
使用这个，我们得到 `r nrow(subset(table_UC, P.Value < 0.001))` 
个被鉴定为 UC 差异表达的基因：


```{r pCutForCD}
nrow(subset(table_UC, P.Value < 0.001))
```


然而，
不可能确定该列表中假阳性基因数量的精确界限。
我们所说的使用 p 值的是我们列表中最多 
`r nrow(table_UC)` (测试总数) * 0.001
= `r nrow(table_UC)* 0.001` 个假阳性基因。
因此，通过选择 0.001 的 p 值截止值，
鉴定为差异表达的基因中多达
`r round(nrow(table_UC)* 0.001 / nrow(subset(table_UC, P.Value < 0.001))*100, 2)`% 
可能是假阳性。

因此，我们可以看到，当同时观察许多测试时，“原始” p 值非常“自由”。
因此，我们需要适应多种测试情况的错误率。 
到目前为止，分子生物学中最受欢迎的是错误发现率 **false discovery rate** 或简称 FDR。 
这是所有积极因素中误报的百分比。
正如我们所看到的，
使用简单的 p 值截止值列出的基因列表
的 FDR 可能非常高。

另一方面，我们可以看到由差异表达的基因引起的 p 值直方图中的清晰峰值 
(Figure \@ref(fig:extractResultsUC)),
在那里，
我们预计列表的实际 FDR 会更低。

给定截止值下的 FDR
由结果表中的“调整后的” p 值给出。

```{r FDRforUC}
tail(subset(table_UC, P.Value < 0.001))
```

表中原始 p 值 0.001 
的调整后的 p 值为 `r max(subset(table_UC, P.Value < 0.001)$adj.P.Val)`,
这比我们仅从 p 值推断
的 FDR 低一个数量级。

因此，尽管一般不推荐这样做，
但我们还在下面使用 0.001 的 p 值截止值，
以便能够将我们的工作流程结果与纸张结果进行比较。

论文结果可以从
[http://links.lww.com/IBD/A795](http://links.lww.com/IBD/A795) 
下载为 .xlsx 文件， 
并应保存为工作目录中名为 `palmieri_DE_res.xlsx`

请注意，虽然本文使用 p 值截止值，
但它也会报告相应的 FDR（就像我们在此处对 UC 数据所做的那样）。

对于 p 值截止值为 0.001，相应的 FDR 在克罗恩病中为 0.05，
在溃疡性结肠炎中为 0.02。
总共有四个表，
分别给出 CD 和 UC 中上调和下调基因的列表。
我们计算了我们的结果与论文中的结果之间的重叠，
即两种分析中发现的基因与仅在论文中发现的基因的比率。

我们还计算了在工作流分析中
发现的差异表达基因的总数。
 
```{r compareDEgenes, dependson=c("extractResultsUC", "extractResultsCD")}
fpath <- system.file("extdata", "palmieri_DE_res.xlsx", package = "maEndToEnd")
palmieri_DE_res <- sapply(1:4, function(i) read.xlsx(cols = 1, fpath, 
                                                     sheet = i, startRow = 4))

names(palmieri_DE_res) <- c("CD_UP", "CD_DOWN", "UC_UP", "UC_DOWN")
palmieri_DE_res <- lapply(palmieri_DE_res, as.character)
paper_DE_genes_CD <- Reduce("c", palmieri_DE_res[1:2])
paper_DE_genes_UC <- Reduce("c", palmieri_DE_res[3:4])

overlap_CD <- length(intersect(subset(table_CD, P.Value < 0.001)$SYMBOL,  
                               paper_DE_genes_CD)) / length(paper_DE_genes_CD)


overlap_UC <- length(intersect(subset(table_UC, P.Value < 0.001)$SYMBOL,
                               paper_DE_genes_UC)) / length(paper_DE_genes_UC)
overlap_CD
overlap_UC 

total_genenumber_CD <- length(subset(table_CD, P.Value < 0.001)$SYMBOL)
total_genenumber_UC <- length(subset(table_UC, P.Value < 0.001)$SYMBOL)

total_genenumber_CD
total_genenumber_UC
```

我们发现 `r total_genenumber_CD` (CD) 和 `r total_genenumber_UC` (UC) 
差异表达的基因（“DE-基因”）。

在该论文中，在相同的截止值下发现了两种疾病的 298 (CD) and 520 (UC) DE基因。
鉴定的这种更高数量的 DE-基因可能是由于
根据个体的阻断功率增加以及
`r Biocpkg("limma") ` 执行的调节方差估计。

我们看到我们得到 CD 的 `r overlap_CD`  和
UC 的 `r overlap_UC` 的适度重叠，
表明两种分析都会导致一些可比较的结果。

## DE 分析结果的可视化 - 火山图

为了显示差异表达的基因，我们创建了一个火山图， 
通常用于总结单个图中差异表达分析的结果。

为了更好地概述，我们只显示倍数大于 1 的基因的基因符号，
我们在 `volcano_names` 对象中定义。
`volcanoplot` 函数中 `highlight` 高亮选项设置为 100，
因此仅标记具有最低 p 值的 100 个基因。

```{r VolcanoPlot, fig.cap="Volcano plot of the DE-genes", fig.height=8, fig.width=7}

volcano_names <- ifelse(abs(palmieri_fit_CD$coefficients)>=1, 
                        palmieri_fit_CD$genes$SYMBOL, NA)
             
             
volcanoplot(palmieri_fit_CD, coef = 1L, style = "p-value", highlight = 100, 
            names = volcano_names,
            xlab = "Log2 Fold Change", ylab = NULL, pch=16, cex=0.35)
```

我们现在可以对显示高倍数变化的基因的生物学功能进行一些研究，
例如在图的右侧具有符号 S100A8 的基因
(Figure \@ref(fig:VolcanoPlot)). 如果我们在
[genecards.org](https://www.genecards.org) 上搜索这个基因符号，
我们发现它编码的蛋白质构建了
与另一种蛋白质相关的促炎复合物。

# 基因本体论（GO）为基础的浓缩分析

如上所述，建议在差分表达式分析中使用 FDR 截止而不是 p 值截止，
因为这样您可以控制明确定义的错误率，
并且结果更易于解释和比较。
对于以下富集分析，
我们分别创建具有 CD 和 UC 的差异表达基因的表，
并选择 10％ 的 FDR 截止值。
在这里，我们关注数据的 CD 子集。


```{r FDRcontrolledDEgenes, dependson=c("extractResultsUC", "extractResultsCD"), eval=TRUE}
DE_genes_CD <- subset(table_CD, adj.P.Val < 0.1)$PROBEID
```

我们现在可以通过进行 GO 富集分析来更详细地表征鉴定的差异表达基因。
本质上，
基因本体论 ([http://www.geneontology.org/](http://www.geneontology.org/))
是一个分层组织的功能基因集合
[@Ashburner_2000; @GO_2015; @du_Plessis_2011]. 

## 匹配背景基因组

来自 `r Biocpkg("genefilter") `包 [@Bourgon_2010] 的
` genefinder ` 函数
将用于找到与差异表达基因的表达相似的基因背景组。 
然后我们检查背景是否具有
与前景大致相同的
平均表达强度分布。 

我们这样做是为了不选择有偏见的背景，
因为基因集测试是在 2x2 表上通过简单的 Fisher 测试进行的。
请注意，此方法与常用的 Web 工具 GOrilla [@Eden_2009] 非常相似。 

对于每个差异表达的基因，我们尝试用
`genefinder` 找到具有相似表达的基因。`genefinder` 函数返回一个列表，
其中包含每个基因的两个元素：
一个具有发现的背景基因的索引，另一个具有与 DE基因的距离：

```{r GOAnalysisCreateBackgrounds, eval=TRUE, warning=FALSE, message=FALSE}
back_genes_idx <- genefilter::genefinder(palmieri_final, 
                                        as.character(DE_genes_CD), 
                                        method = "manhattan", scale = "none")
```

我们必须提取与索引相对应的 PROBEIDs, 我们通过使用
`sapply` 函数来实现这一点，
它为我们提供了一个单独的矩阵，
其中 DE-genes 作为列名，以及下面单元格中相应背景基因的 PROBEID：

```{r GOAnalysisCreateBackgrounds2, eval=TRUE, warning=FALSE, message=FALSE}
back_genes_idx <- sapply(back_genes_idx, function(x)x$indices)
```

然后我们创建一个包含所有背景基因 PROBEID 的载体 `back_genes`：



为了从 `back_genes` 集中消除前景基因，即 DE 基因，
我们使用 `setdiff` 函数。 它返回第一个参数
(`back_genes`) 中不属于第二个参数
(`DE_genes_CD`) 的所有元素。
With the `intersect` function, we verify that we were successful: 
it should return 0, as there shouldn't be any intersect anymore between
`back_genes`and `DE_genes_CD`:

```{r GOAnalysisCreateBackgrounds3, eval=TRUE, warning=FALSE, message=FALSE}
back_genes <- featureNames(palmieri_final)[back_genes_idx]
back_genes <- setdiff(back_genes, DE_genes_CD)

    
intersect(back_genes, DE_genes_CD)
length(back_genes)
```

We create a multidensity plot with mean expression on the x-axis 
and curves for all genes, foreground genes and background genes, respectively 
(Figure \@ref(fig:multidensityPlot)). We want to see whether the background 
genes show a plot similar to the foreground genes so that the background 
is not biased for the gene enrichment analysis:

```{r multidensityPlot, fig.cap="Selecting a background set of genes for the gene ontology analysis."}
multidensity(list(
        all = table_CD[,"AveExpr"] ,
        fore = table_CD[DE_genes_CD , "AveExpr"],
        back = table_CD[rownames(table_CD) %in% back_genes, "AveExpr"]),
        col = c("#e46981", "#ae7ee2", "#a7ad4a"),
     xlab = "mean expression",
   main = "DE genes for CD-background-matching")
```

When comparing the "background gene" curve to the "foreground gene" curve, 
we see a  similar curve shape, indicating a sensible background matching 
(Figure \@ref(fig:multidensityPlot)). Note that the right-shift of the 
"foreground-gene" curve in comparison to the "background-gene" curve 
indicates that DE-genes are generally very
highly expressed, so that it wasn't possible to find background-genes 
with exactly equal overall expression distribution.

The "all gene" curve has the leftmost curve maximum; 
this can be explained by a high number of lowly expressed genes 
in all samples and shows that a background matching is sensible 
in order to avoid biases.

For the actual testing of which GO gene sets are enriched in inflamed tissue, 
we use the `r Biocpkg("topGO")` package which implements a nice interface 
to Fisher testing and also has additional algorithms
taking the GO structure into account, by e.g. only reporting the most specific
gene set in the hierarchy [@Alexa_2006].

The GO has three top ontologies: Cellular component (CC), biological processes
(BP), and molecular function (MF). For illustrative purposes we limit ourselves 
to the BP category here. 

## Running topGO

topGO requires a topGOdata object containing the necessary information for the 
analysis. We follow the steps described in the topGO vignettes: First, 
we will create a named vector `all_genes` with all genes to be analyzed, i.e. 
DE-genes and background genes: 

```{r createFactorOfInterestingGenes, dependson="GOAnalysisCreateBackgrounds", eval=TRUE}
gene_IDs <- rownames(table_CD)
in_universe <- gene_IDs %in% c(DE_genes_CD, back_genes)
in_selection <- gene_IDs %in% DE_genes_CD 

all_genes <- in_selection[in_universe]
all_genes <- factor(as.integer(in_selection[in_universe]))
names(all_genes) <- gene_IDs[in_universe] 
```

The following steps were carried through: 

  1. we created an `in_universe` vector by using the `%in%` matching function. 
  We want to know which elements from `gene_IDs` are also contained in 
  `DE_genes_CD` and `back_genes`, as the latter two are our gene universe 
  we use for enrichment analysis.
  We got a vector `in_universe` with the length of `gene_IDs` that has the 
  entry `TRUE` when the corresponding gene in `gene_IDs` could be also found in 
  `DE_genes_CD` or `back_genes`, and `FALSE` otherwise.
  
  2. We did the same for our DE-genes and call this vector `in_selection`.
  
  3. We created the `all_genes` vector:
    a) First, we selected all the elements from `in_selection` 
    that are `TRUE` in `in_universe` by applying
    `all_genes <- in_selection[in_universe]`.
    b) Then, we converted the elements in `all_genes` from `TRUE` and `FALSE` 
    to 0 and 1 by converting the vector to an integer vector. 
    This way, each element in the vector is a 0 if the corresponding gene is a
    background gene and a 1 if the corresponding gene is a DE-gene. Also, we 
    converted the vector to a factor.
    c) We named the vector elements with the corresponding `gene_IDs`.


We now initialize the `r Biocpkg("topGO") ` data set, using the GO annotations 
contained in the annotation data base for the chip we are using. The `nodeSize`
parameter specifies a minimum size of a GO category we want to use: i.e. here,
categories with less than 10 genes are not included in the testing.

```{r createTopGODataSet, dependson="createFactorOfInterestingGenes", eval=TRUE, message = FALSE, warning=FALSE}
top_GO_data <- new("topGOdata", ontology = "BP", allGenes = all_genes,
 nodeSize = 10, annot = annFUN.db, affyLib = "hugene10sttranscriptcluster.db")
```

Now the tests can be run. `r Biocpkg("topGO") ` offers a wide range of options,
for details see the paper [@Alexa_2006] or the package vignette.

We run two common tests: an ordinary Fisher test for every GO category, and the
"elim" algorithm, which tries to incorporate the hierarchical structure of the
GO and tries to "decorrelate" it in order to report the most specific 
significant term in the hierarchy.

The algorithm starts processing the nodes / GO categories
from the highest (bottommost) level and then iteratively
moves to nodes from a lower level. If a node is scored as significant,
all of its genes are marked as removed in all ancestor nodes.
This way, the "elim" algorithm aims at finding the most specific node
for every gene.

The test uses a 0.01 p-value cutoff by default.

```{r runtopGOTests, results='hide', eval=TRUE, dependson = "createTopGODataSet", message = FALSE}
result_top_GO_elim <- 
  runTest(top_GO_data, algorithm = "elim", statistic = "Fisher")
result_top_GO_classic <- 
  runTest(top_GO_data, algorithm = "classic", statistic = "Fisher")
```

We can now inspect the results. We look at the top 100 GO categories according
to the "Fisher elim" algorithm. The function `GenTable` produces
a table of significant GO categories, the function `printGenes`
gives genes annotated to them; the significant ones are denoted with a "2"
in the "raw  p-value" column, the non-significant ones with a "1". 
We therefore select `raw p-value == 2`. 

Note that we do not get the actual p-values here because our `all_genes` vector 
doesn't contain this information; it only tells us
whether a gene is differentially  expressed or not.

```{r processtopGOResults, eval=TRUE, dependson="runtopGOTests"}
res_top_GO <- GenTable(top_GO_data, Fisher.elim = result_top_GO_elim,
        Fisher.classic = result_top_GO_classic,
        orderBy = "Fisher.elim" , topNodes = 100)

genes_top_GO <- printGenes(top_GO_data, whichTerms = res_top_GO$GO.ID,
    chip = "hugene10sttranscriptcluster.db", geneCutOff = 1000)

res_top_GO$sig_genes <- sapply(genes_top_GO, function(x){
                str_c(paste0(x[x$'raw p-value' == 2, "Symbol.id"],";"), 
                      collapse = "")
    })

head(res_top_GO[,1:8], 20)
```

## Visualization of the GO-analysis results

A graph of the results can also be produced. Here we visualize the three most
significant nodes according to the Fisher elim algorithm in the context of
the GO hierarchy.


```{r graphOfResults, fig.height = 6, eval=TRUE, results='hide', dpi=600, fig.cap="Significantly enriched GO nodes in the GO hierarchy"}
showSigOfNodes(top_GO_data, score(result_top_GO_elim), firstSigNodes = 3,
               useInfo = 'def')
```

We can see that indeed GO categories related to inflammation, signalling and 
immune response come up as significant (Figure \@ref(fig:graphOfResults))
Gene set enrichment analysis has been a field of very extensive
research in bioinformatics. For additional approaches
see the `r Biocpkg("topGO") ` vignette and the references therein 
and also in the [GeneSetEnrichment view](http://bioconductor.org/packages/release/BiocViews.html#___GeneSetEnrichment). 


# A pathway enrichment analysis using reactome

The package `r Biocpkg("ReactomePA") ` offers the possibility to test enrichment
of specific pathways using the free, open-source, curated and peer reviewed 
[Reactome](http://www.reactome.org/) pathway database [@Croft_2013; @Fabregat_2017]. 
The package requires entrez identifiers, so we convert our PROBEIDs 
(transcript cluster identifiers) to entrez identifiers 
using the function `mapIDs` from the package `r Biocpkg("AnnotationDbi")`. 
This will create a named vector that maps the PROBEIDs to the entrez ones, 
with the PROBEIDs as names and the entrez ids as vector elements.


```{r mapIDsToEntrez, dependson="createFactorOfInterestingGenes", message = FALSE}
entrez_ids <- mapIds(hugene10sttranscriptcluster.db, 
      keys = rownames(table_CD), 
      keytype = "PROBEID",
      column = "ENTREZID")
```

We can now run the enrichment analysis that performs a statistical test
based on the hypergeoemtric distribution that is the same as a one sided 
Fisher-test, which `r Biocpkg("topGO")` calls "Fisher-classic".
Details can be found in the vignette of the `r Biocpkg("DOSE")` 
package [@Yu_2014].

```{r runReactomeEnrichment, fig.cap="Enriched Reactome pathways and their p–values as a bar chart.", eval = TRUE, warning=FALSE}
reactome_enrich <- enrichPathway(gene = entrez_ids[DE_genes_CD], 
                                universe = entrez_ids[c(DE_genes_CD, 
                                                        back_genes)],
                                organism = "human",
                                pvalueCutoff = 0.05,
                                qvalueCutoff = 0.9, 
                                readable = TRUE)

reactome_enrich@result$Description <- paste0(str_sub(
                                    reactome_enrich@result$Description, 1, 20),
                                    "...")

head(as.data.frame(reactome_enrich))[1:6]
```

Note that we trimmed pathway names to 20 characters.

## Visualizing the reactome based analysis results 

The top pathways can be displayed as a bar chart that displays all categories
with a p-value below the specified cutoff (Figure \@ref(fig:reactomeBar)).

```{r reactomeBar, dependson="runReactomeEnrichment", fig.cap="Enriched Reactome pathways and their p–values as a bar chart."}
barplot(reactome_enrich)
```

The "enrichment map" from the package `r Biocpkg("enrichplot")` 
displays the results of the enrichment analysis as 
a graph, where the color represents the p-value of the pathway and the
edge-thickness (that is the line connecting two pathways) is proportional 
to the number of overlapping genes between two pathways.

```{r emapplot, dependson="runReactomeEnrichment", fig.width=6, fig.height = 7, fig.cap="Enriched Reactome pathways enrichment results as a graph."}
emapplot(reactome_enrich, showCategory = 10)
```

Again, the graph in Figure \@ref(fig:emapplot) shows pathways related 
to signalling and immune response. 

The package `r Biocpkg("clusterProfiler") ` [@Yu_2012] can also perform these 
analyses using downloaded KEGG data. Furthermore, 
the package `r Biocpkg("EnrichmentBrowser")`
[@Geistlinger_2016] additionally offers network-based enrichment analysis of individual 
pathways. This allows the mapping of the expression data at hand to known
regulatory interactions.


# Session information

As the last part of this document, we call the function *sessionInfo*,
which reports the version numbers of R and all the packages used in
this session. It is good practice to always keep such a record of this
as it will help to track down what has happened in case an R script
ceases to work or gives different results because the functions have
been changed in a newer version of one of your packages. By including
it at the bottom of a script, your reports will become more reproducible.

The session information should also *always*
be included in any emails to the
[Bioconductor support site](https://support.bioconductor.org) along
with all code used in the analysis.

```{r}
gc()

length(getLoadedDLLs())

sessionInfo()
```


# Acknowledgements

The authors would like to thank Vladislava Milchevskaya, 
Julian Gehring and Mike Smith for helpful comments on and small contributions 
to the workflow. They also would like to thank Frederik Ziebell, Holly Giles and 
Jennifer Huellein for proof-reading.

This workflow draws a lot of inspiration from the Bioconductor 
books [@Bioc2005; @useRbook2008] as well as Love et. al.'s workflow 
for gene level analysis of RNA-Seq data [@Love_2016]. James W. MacDonald 
provided valuable information on the evolution of Affymetrix arrays in some of 
his posts of on the Biocondctor support site. 
BK would also like to thank him for some friendly personal 
correspondence about the annotation resources available
for microarrays in Bioconductor.



# Author Contributions

BK produced the first version of this article. 
BK implemented the main scaffold of the workflow and designed 
the workflow steps. SR implemented additional workflow steps and 
improved existing ones from version 1. BK and SR wrote the article.


# References

